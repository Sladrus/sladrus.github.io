{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _createForOfIteratorHelper = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _regeneratorRuntime = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _defineProperty = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nvar _classCallCheck = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MTProtoSender = void 0;\n/**\r\n * MTProto Mobile Protocol sender\r\n * (https://core.telegram.org/mtproto/description)\r\n * This class is responsible for wrapping requests into `TLMessage`'s,\r\n * sending them over the network and receiving them in a safe manner.\r\n *\r\n * Automatic reconnection due to temporary network issues is a concern\r\n * for this class as well, including retry of messages that could not\r\n * be sent successfully.\r\n *\r\n * A new authorization key will be generated on connection if no other\r\n * key exists yet.\r\n */\nvar AuthKey_1 = require(\"../crypto/AuthKey\");\nvar MTProtoState_1 = require(\"./MTProtoState\");\nvar extensions_1 = require(\"../extensions\");\nvar extensions_2 = require(\"../extensions\");\nvar core_1 = require(\"../tl/core\");\nvar tl_1 = require(\"../tl\");\nvar big_integer_1 = __importDefault(require(\"big-integer\"));\nvar Helpers_1 = require(\"../Helpers\");\nvar RequestState_1 = require(\"./RequestState\");\nvar Authenticator_1 = require(\"./Authenticator\");\nvar MTProtoPlainSender_1 = require(\"./MTProtoPlainSender\");\nvar errors_1 = require(\"../errors\");\nvar _1 = require(\"./\");\nvar Logger_1 = require(\"../extensions/Logger\");\nvar async_mutex_1 = require(\"async-mutex\");\nvar real_cancellable_promise_1 = require(\"real-cancellable-promise\");\nvar MTProtoSender = /*#__PURE__*/function () {\n  /**\r\n   * @param authKey\r\n   * @param opts\r\n   */\n  function MTProtoSender(authKey, opts) {\n    var _this$_handlers;\n    _classCallCheck(this, MTProtoSender);\n    var args = Object.assign(Object.assign({}, MTProtoSender.DEFAULT_OPTIONS), opts);\n    this._cancelSend = false;\n    this._connection = undefined;\n    this._log = args.logger;\n    this._dcId = args.dcId;\n    this._retries = args.retries;\n    this._delay = args.delay;\n    this._autoReconnect = args.autoReconnect;\n    this._connectTimeout = args.connectTimeout;\n    this._authKeyCallback = args.authKeyCallback;\n    this._updateCallback = args.updateCallback;\n    this._autoReconnectCallback = args.autoReconnectCallback;\n    this._isMainSender = args.isMainSender;\n    this._senderCallback = args.senderCallback;\n    this._client = args.client;\n    this._onConnectionBreak = args.onConnectionBreak;\n    this._securityChecks = args.securityChecks;\n    this._connectMutex = new async_mutex_1.Mutex();\n    /**\r\n     * whether we disconnected ourself or telegram did it.\r\n     */\n    this.userDisconnected = false;\n    /**\r\n     * If a disconnection happens for any other reason and it\r\n     * was *not* user action then the pending messages won't\r\n     * be cleared but on explicit user disconnection all the\r\n     * pending futures should be cancelled.\r\n     */\n    this.isConnecting = false;\n    this._authenticated = false;\n    this._userConnected = false;\n    this._reconnecting = false;\n    this._disconnected = true;\n    /**\r\n     * We need to join the loops upon disconnection\r\n     */\n    this._sendLoopHandle = null;\n    this._recvLoopHandle = null;\n    /**\r\n     * Preserving the references of the AuthKey and state is important\r\n     */\n    this.authKey = authKey || new AuthKey_1.AuthKey();\n    this._state = new MTProtoState_1.MTProtoState(this.authKey, this._log, this._securityChecks);\n    /**\r\n     * Outgoing messages are put in a queue and sent in a batch.\r\n     * Note that here we're also storing their ``_RequestState``.\r\n     */\n    this._sendQueue = new extensions_2.MessagePacker(this._state, this._log);\n    /**\r\n     * Sent states are remembered until a response is received.\r\n     */\n    this._pendingState = new Map();\n    /**\r\n     * Responses must be acknowledged, and we can also batch these.\r\n     */\n    this._pendingAck = new Set();\n    /**\r\n     * Similar to pending_messages but only for the last acknowledges.\r\n     * These can't go in pending_messages because no acknowledge for them\r\n     * is received, but we may still need to resend their state on bad salts.\r\n     */\n    this._lastAcks = [];\n    /**\r\n     * Jump table from response ID to method that handles it\r\n     */\n    this._handlers = (_this$_handlers = {}, _defineProperty(_this$_handlers, core_1.RPCResult.CONSTRUCTOR_ID.toString(), this._handleRPCResult.bind(this)), _defineProperty(_this$_handlers, core_1.MessageContainer.CONSTRUCTOR_ID.toString(), this._handleContainer.bind(this)), _defineProperty(_this$_handlers, core_1.GZIPPacked.CONSTRUCTOR_ID.toString(), this._handleGzipPacked.bind(this)), _defineProperty(_this$_handlers, tl_1.Api.Pong.CONSTRUCTOR_ID.toString(), this._handlePong.bind(this)), _defineProperty(_this$_handlers, tl_1.Api.BadServerSalt.CONSTRUCTOR_ID.toString(), this._handleBadServerSalt.bind(this)), _defineProperty(_this$_handlers, tl_1.Api.BadMsgNotification.CONSTRUCTOR_ID.toString(), this._handleBadNotification.bind(this)), _defineProperty(_this$_handlers, tl_1.Api.MsgDetailedInfo.CONSTRUCTOR_ID.toString(), this._handleDetailedInfo.bind(this)), _defineProperty(_this$_handlers, tl_1.Api.MsgNewDetailedInfo.CONSTRUCTOR_ID.toString(), this._handleNewDetailedInfo.bind(this)), _defineProperty(_this$_handlers, tl_1.Api.NewSessionCreated.CONSTRUCTOR_ID.toString(), this._handleNewSessionCreated.bind(this)), _defineProperty(_this$_handlers, tl_1.Api.MsgsAck.CONSTRUCTOR_ID.toString(), this._handleAck.bind(this)), _defineProperty(_this$_handlers, tl_1.Api.FutureSalts.CONSTRUCTOR_ID.toString(), this._handleFutureSalts.bind(this)), _defineProperty(_this$_handlers, tl_1.Api.MsgsStateReq.CONSTRUCTOR_ID.toString(), this._handleStateForgotten.bind(this)), _defineProperty(_this$_handlers, tl_1.Api.MsgResendReq.CONSTRUCTOR_ID.toString(), this._handleStateForgotten.bind(this)), _defineProperty(_this$_handlers, tl_1.Api.MsgsAllInfo.CONSTRUCTOR_ID.toString(), this._handleMsgAll.bind(this)), _this$_handlers);\n  }\n  _createClass(MTProtoSender, [{\n    key: \"dcId\",\n    get: function get() {\n      return this._dcId;\n    }\n    // Public API\n    /**\r\n     * Connects to the specified given connection using the given auth key.\r\n     */,\n    set: function set(dcId) {\n      this._dcId = dcId;\n    }\n  }, {\n    key: \"connect\",\n    value: function () {\n      var _connect2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(connection) {\n        var release;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return this._connectMutex.acquire();\n            case 2:\n              release = _context.sent;\n              _context.prev = 3;\n              if (!this._userConnected) {\n                _context.next = 7;\n                break;\n              }\n              this._log.info(\"User is already connected!\");\n              return _context.abrupt(\"return\", false);\n            case 7:\n              this._connection = connection;\n              _context.next = 10;\n              return this._connect();\n            case 10:\n              this._userConnected = true;\n              return _context.abrupt(\"return\", true);\n            case 12:\n              _context.prev = 12;\n              release();\n              return _context.finish(12);\n            case 15:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[3,, 12, 15]]);\n      }));\n      function connect(_x) {\n        return _connect2.apply(this, arguments);\n      }\n      return connect;\n    }()\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      return this._userConnected;\n    }\n  }, {\n    key: \"_transportConnected\",\n    value: function _transportConnected() {\n      return !this._reconnecting && this._connection && this._connection._connected;\n    }\n    /**\r\n     * Cleanly disconnects the instance from the network, cancels\r\n     * all pending requests, and closes the send and receive loops.\r\n     */\n  }, {\n    key: \"disconnect\",\n    value: function () {\n      var _disconnect2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var release;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return this._connectMutex.acquire();\n            case 2:\n              release = _context2.sent;\n              _context2.prev = 3;\n              _context2.next = 6;\n              return this._disconnect();\n            case 6:\n              _context2.next = 11;\n              break;\n            case 8:\n              _context2.prev = 8;\n              _context2.t0 = _context2[\"catch\"](3);\n              this._log.error(_context2.t0);\n            case 11:\n              _context2.prev = 11;\n              release();\n              return _context2.finish(11);\n            case 14:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this, [[3, 8, 11, 14]]);\n      }));\n      function disconnect() {\n        return _disconnect2.apply(this, arguments);\n      }\n      return disconnect;\n    }()\n    /**\r\n     *\r\n     This method enqueues the given request to be sent. Its send\r\n     state will be saved until a response arrives, and a ``Future``\r\n     that will be resolved when the response arrives will be returned:\r\n       .. code-block:: javascript\r\n       async def method():\r\n     # Sending (enqueued for the send loop)\r\n     future = sender.send(request)\r\n     # Receiving (waits for the receive loop to read the result)\r\n     result = await future\r\n       Designed like this because Telegram may send the response at\r\n     any point, and it can send other items while one waits for it.\r\n     Once the response for this future arrives, it is set with the\r\n     received result, quite similar to how a ``receive()`` call\r\n     would otherwise work.\r\n       Since the receiving part is \"built in\" the future, it's\r\n     impossible to await receive a result that was never sent.\r\n     * @param request\r\n     * @returns {RequestState}\r\n     */\n  }, {\n    key: \"send\",\n    value: function send(request) {\n      if (!this._userConnected) {\n        throw new Error(\"Cannot send requests while disconnected. You need to call .connect()\");\n      }\n      var state = new RequestState_1.RequestState(request);\n      this._sendQueue.append(state);\n      return state.promise;\n    }\n    /**\r\n     * Performs the actual connection, retrying, generating the\r\n     * authorization key if necessary, and starting the send and\r\n     * receive loops.\r\n     * @returns {Promise<void>}\r\n     * @private\r\n     */\n  }, {\n    key: \"_connect\",\n    value: function () {\n      var _connect3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var connected, attempt, error;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              this._log.info(\"Connecting to {0} using {1}\".replace(\"{0}\", this._connection.toString()).replace(\"{1}\", this._connection.socket.toString()));\n              connected = false;\n              attempt = 0;\n            case 3:\n              if (!(attempt < this._retries)) {\n                _context3.next = 36;\n                break;\n              }\n              if (connected) {\n                _context3.next = 10;\n                break;\n              }\n              _context3.next = 7;\n              return this._tryConnect(attempt);\n            case 7:\n              connected = _context3.sent;\n              if (connected) {\n                _context3.next = 10;\n                break;\n              }\n              return _context3.abrupt(\"continue\", 33);\n            case 10:\n              if (this.authKey.getKey()) {\n                _context3.next = 30;\n                break;\n              }\n              _context3.prev = 11;\n              _context3.next = 14;\n              return this._tryGenAuthKey(attempt);\n            case 14:\n              if (_context3.sent) {\n                _context3.next = 16;\n                break;\n              }\n              return _context3.abrupt(\"continue\", 33);\n            case 16:\n              _context3.next = 28;\n              break;\n            case 18:\n              _context3.prev = 18;\n              _context3.t0 = _context3[\"catch\"](11);\n              this._log.warn(\"Connection error \".concat(attempt, \" during auth_key gen\"));\n              if (this._log.canSend(Logger_1.LogLevel.ERROR)) {\n                console.error(_context3.t0);\n              }\n              _context3.next = 24;\n              return this._connection.disconnect();\n            case 24:\n              connected = false;\n              _context3.next = 27;\n              return (0, Helpers_1.sleep)(this._delay);\n            case 27:\n              return _context3.abrupt(\"continue\", 33);\n            case 28:\n              _context3.next = 32;\n              break;\n            case 30:\n              this._authenticated = true;\n              this._log.debug(\"Already have an auth key ...\");\n            case 32:\n              return _context3.abrupt(\"break\", 36);\n            case 33:\n              attempt++;\n              _context3.next = 3;\n              break;\n            case 36:\n              if (connected) {\n                _context3.next = 38;\n                break;\n              }\n              throw new Error(\"Connection to telegram failed after \".concat(this._retries, \" time(s)\"));\n            case 38:\n              if (this.authKey.getKey()) {\n                _context3.next = 43;\n                break;\n              }\n              error = new Error(\"auth key generation failed after \".concat(this._retries, \" time(s)\"));\n              _context3.next = 42;\n              return this._disconnect(error);\n            case 42:\n              throw error;\n            case 43:\n              this._userConnected = true;\n              this._log.debug(\"Starting receive loop\");\n              this._recvLoopHandle = this._recvLoop();\n              this._log.debug(\"Starting send loop\");\n              this._sendLoopHandle = this._sendLoop();\n              this._log.info(\"Connection to %s complete!\".replace(\"%s\", this._connection.toString()));\n            case 49:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this, [[11, 18]]);\n      }));\n      function _connect() {\n        return _connect3.apply(this, arguments);\n      }\n      return _connect;\n    }()\n  }, {\n    key: \"_disconnect\",\n    value: function () {\n      var _disconnect3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(error) {\n        var _iterator, _step, state;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              if (this._connection) {\n                _context4.next = 3;\n                break;\n              }\n              this._log.info(\"Not disconnecting (already have no connection)\");\n              return _context4.abrupt(\"return\");\n            case 3:\n              this._log.info(\"Disconnecting from %s...\".replace(\"%s\", this._connection.toString()));\n              this._userConnected = false;\n              _context4.prev = 5;\n              this._log.debug(\"Closing current connection...\");\n              _context4.next = 9;\n              return this._connection.disconnect();\n            case 9:\n              _context4.prev = 9;\n              this._log.debug(\"Cancelling \".concat(this._pendingState.size, \" pending message(s)...\"));\n              _iterator = _createForOfIteratorHelper(this._pendingState.values());\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  state = _step.value;\n                  if (error && !state.result) {\n                    state.reject(error);\n                  } else {\n                    state.reject(\"disconnected\");\n                  }\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n              this._pendingState.clear();\n              this._cancelLoops();\n              this._log.info(\"Disconnecting from %s complete!\".replace(\"%s\", this._connection.toString()));\n              this._connection = undefined;\n              return _context4.finish(9);\n            case 18:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this, [[5,, 9, 18]]);\n      }));\n      function _disconnect(_x2) {\n        return _disconnect3.apply(this, arguments);\n      }\n      return _disconnect;\n    }()\n  }, {\n    key: \"_cancelLoops\",\n    value: function _cancelLoops() {\n      this._cancelSend = true;\n      this.cancellableRecvLoopPromise.cancel();\n    }\n    /**\r\n     * This loop is responsible for popping items off the send\r\n     * queue, encrypting them, and sending them over the network.\r\n     * Besides `connect`, only this method ever sends data.\r\n     * @returns {Promise<void>}\r\n     * @private\r\n     */\n  }, {\n    key: \"_sendLoop\",\n    value: function () {\n      var _sendLoop2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var ack, res, data, batch, _iterator2, _step2, state, _iterator3, _step3, s;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              this._cancelSend = false;\n            case 1:\n              if (!(this._userConnected && !this._reconnecting && !this._cancelSend)) {\n                _context5.next = 31;\n                break;\n              }\n              if (this._pendingAck.size) {\n                ack = new RequestState_1.RequestState(new tl_1.Api.MsgsAck({\n                  msgIds: Array.apply(void 0, _toConsumableArray(this._pendingAck))\n                }));\n                this._sendQueue.append(ack);\n                this._lastAcks.push(ack);\n                if (this._lastAcks.length >= 10) {\n                  this._lastAcks.shift();\n                }\n                this._pendingAck.clear();\n              }\n              this._log.debug(\"Waiting for messages to send...\" + this._reconnecting);\n              // TODO Wait for the connection send queue to be empty?\n              // This means that while it's not empty we can wait for\n              // more messages to be added to the send queue.\n              _context5.next = 6;\n              return this._sendQueue.get();\n            case 6:\n              res = _context5.sent;\n              if (res) {\n                _context5.next = 9;\n                break;\n              }\n              return _context5.abrupt(\"continue\", 1);\n            case 9:\n              data = res.data;\n              batch = res.batch;\n              this._log.debug(\"Encrypting \".concat(batch.length, \" message(s) in \").concat(data.length, \" bytes for sending\"));\n              _context5.next = 14;\n              return this._state.encryptMessageData(data);\n            case 14:\n              data = _context5.sent;\n              _iterator2 = _createForOfIteratorHelper(batch);\n              try {\n                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                  state = _step2.value;\n                  if (!Array.isArray(state)) {\n                    if (state.request.classType === \"request\") {\n                      this._pendingState.set(state.msgId.toString(), state);\n                    }\n                  } else {\n                    _iterator3 = _createForOfIteratorHelper(state);\n                    try {\n                      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                        s = _step3.value;\n                        if (s.request.classType === \"request\") {\n                          this._pendingState.set(s.msgId.toString(), s);\n                        }\n                      }\n                    } catch (err) {\n                      _iterator3.e(err);\n                    } finally {\n                      _iterator3.f();\n                    }\n                  }\n                }\n              } catch (err) {\n                _iterator2.e(err);\n              } finally {\n                _iterator2.f();\n              }\n              _context5.prev = 17;\n              _context5.next = 20;\n              return this._connection.send(data);\n            case 20:\n              _context5.next = 28;\n              break;\n            case 22:\n              _context5.prev = 22;\n              _context5.t0 = _context5[\"catch\"](17);\n              this._log.error(_context5.t0);\n              this._log.info(\"Connection closed while sending data\");\n              this._startReconnecting(_context5.t0);\n              return _context5.abrupt(\"return\");\n            case 28:\n              this._log.debug(\"Encrypted messages put in a queue to be sent\");\n              _context5.next = 1;\n              break;\n            case 31:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this, [[17, 22]]);\n      }));\n      function _sendLoop() {\n        return _sendLoop2.apply(this, arguments);\n      }\n      return _sendLoop;\n    }()\n  }, {\n    key: \"_recvLoop\",\n    value: function () {\n      var _recvLoop2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var body, message;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              if (!(this._userConnected && !this._reconnecting)) {\n                _context6.next = 63;\n                break;\n              }\n              this._log.debug(\"Receiving items from the network...\");\n              _context6.prev = 2;\n              this.cancellableRecvLoopPromise = (0, real_cancellable_promise_1.pseudoCancellable)(this._connection.recv());\n              _context6.next = 6;\n              return this.cancellableRecvLoopPromise;\n            case 6:\n              body = _context6.sent;\n              _context6.next = 17;\n              break;\n            case 9:\n              _context6.prev = 9;\n              _context6.t0 = _context6[\"catch\"](2);\n              if (!(_context6.t0 instanceof real_cancellable_promise_1.Cancellation)) {\n                _context6.next = 13;\n                break;\n              }\n              return _context6.abrupt(\"return\");\n            case 13:\n              this._log.error(_context6.t0);\n              this._log.warn(\"Connection closed while receiving data...\");\n              this._startReconnecting(_context6.t0);\n              return _context6.abrupt(\"return\");\n            case 17:\n              _context6.prev = 17;\n              _context6.next = 20;\n              return this._state.decryptMessageData(body);\n            case 20:\n              message = _context6.sent;\n              _context6.next = 52;\n              break;\n            case 23:\n              _context6.prev = 23;\n              _context6.t1 = _context6[\"catch\"](17);\n              if (!(_context6.t1 instanceof errors_1.TypeNotFoundError)) {\n                _context6.next = 30;\n                break;\n              }\n              // Received object which we don't know how to deserialize\n              this._log.info(\"Type \".concat(_context6.t1.invalidConstructorId, \" not found, remaining data \").concat(_context6.t1.remaining));\n              return _context6.abrupt(\"continue\", 0);\n            case 30:\n              if (!(_context6.t1 instanceof errors_1.SecurityError)) {\n                _context6.next = 35;\n                break;\n              }\n              // A step while decoding had the incorrect data. This message\n              // should not be considered safe and it should be ignored.\n              this._log.warn(\"Security error while unpacking a received message: \".concat(_context6.t1));\n              return _context6.abrupt(\"continue\", 0);\n            case 35:\n              if (!(_context6.t1 instanceof errors_1.InvalidBufferError)) {\n                _context6.next = 48;\n                break;\n              }\n              if (!(_context6.t1.code === 404)) {\n                _context6.next = 43;\n                break;\n              }\n              this._log.warn(\"Broken authorization key for dc \".concat(this._dcId, \"; resetting\"));\n              if (this._updateCallback && this._isMainSender) {\n                this._updateCallback(this._client, new _1.UpdateConnectionState(_1.UpdateConnectionState.broken));\n              } else if (this._onConnectionBreak && !this._isMainSender) {\n                // Deletes the current sender from the object\n                this._onConnectionBreak(this._dcId);\n              }\n              _context6.next = 41;\n              return this._disconnect(_context6.t1);\n            case 41:\n              _context6.next = 45;\n              break;\n            case 43:\n              // this happens sometimes when telegram is having some internal issues.\n              // reconnecting should be enough usually\n              // since the data we sent and received is probably wrong now.\n              this._log.warn(\"Invalid buffer \".concat(_context6.t1.code, \" for dc \").concat(this._dcId));\n              this._startReconnecting(_context6.t1);\n            case 45:\n              return _context6.abrupt(\"return\");\n            case 48:\n              this._log.error(\"Unhandled error while receiving data\");\n              this._log.error(_context6.t1);\n              this._startReconnecting(_context6.t1);\n              return _context6.abrupt(\"return\");\n            case 52:\n              _context6.prev = 52;\n              _context6.next = 55;\n              return this._processMessage(message);\n            case 55:\n              _context6.next = 61;\n              break;\n            case 57:\n              _context6.prev = 57;\n              _context6.t2 = _context6[\"catch\"](52);\n              this._log.error(\"Unhandled error while processing data\");\n              this._log.error(_context6.t2);\n            case 61:\n              _context6.next = 0;\n              break;\n            case 63:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this, [[2, 9], [17, 23], [52, 57]]);\n      }));\n      function _recvLoop() {\n        return _recvLoop2.apply(this, arguments);\n      }\n      return _recvLoop;\n    }() // Response Handlers\n    /**\r\n     * Adds the given message to the list of messages that must be\r\n     * acknowledged and dispatches control to different ``_handle_*``\r\n     * method based on its type.\r\n     * @param message\r\n     * @returns {Promise<void>}\r\n     * @private\r\n     */\n  }, {\n    key: \"_processMessage\",\n    value: function () {\n      var _processMessage2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(message) {\n        var handler;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              this._pendingAck.add(message.msgId);\n              _context7.next = 3;\n              return message.obj;\n            case 3:\n              message.obj = _context7.sent;\n              handler = this._handlers[message.obj.CONSTRUCTOR_ID.toString()];\n              if (!handler) {\n                handler = this._handleUpdate.bind(this);\n              }\n              _context7.next = 8;\n              return handler(message);\n            case 8:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this);\n      }));\n      function _processMessage(_x3) {\n        return _processMessage2.apply(this, arguments);\n      }\n      return _processMessage;\n    }()\n    /**\r\n     * Pops the states known to match the given ID from pending messages.\r\n     * This method should be used when the response isn't specific.\r\n     * @param msgId\r\n     * @returns {*[]}\r\n     * @private\r\n     */\n  }, {\n    key: \"_popStates\",\n    value: function _popStates(msgId) {\n      var state = this._pendingState.get(msgId.toString());\n      if (state) {\n        this._pendingState.delete(msgId.toString());\n        return [state];\n      }\n      var toPop = [];\n      var _iterator4 = _createForOfIteratorHelper(this._pendingState.values()),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _state = _step4.value;\n          if (_state.containerId && _state.containerId.equals(msgId)) {\n            toPop.push(_state.msgId);\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      if (toPop.length) {\n        var temp = [];\n        var _iterator5 = _createForOfIteratorHelper(toPop),\n          _step5;\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var x = _step5.value;\n            temp.push(this._pendingState.get(x.toString()));\n            this._pendingState.delete(x.toString());\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n        return temp;\n      }\n      var _iterator6 = _createForOfIteratorHelper(this._lastAcks),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var ack = _step6.value;\n          if (ack.msgId === msgId) {\n            return [ack];\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n      return [];\n    }\n    /**\r\n     * Handles the result for Remote Procedure Calls:\r\n     * rpc_result#f35c6d01 req_msg_id:long result:bytes = RpcResult;\r\n     * This is where the future results for sent requests are set.\r\n     * @param message\r\n     * @returns {Promise<void>}\r\n     * @private\r\n     */\n  }, {\n    key: \"_handleRPCResult\",\n    value: function _handleRPCResult(message) {\n      var RPCResult = message.obj;\n      var state = this._pendingState.get(RPCResult.reqMsgId.toString());\n      if (state) {\n        this._pendingState.delete(RPCResult.reqMsgId.toString());\n      }\n      this._log.debug(\"Handling RPC result for message \".concat(RPCResult.reqMsgId));\n      if (!state) {\n        // TODO We should not get responses to things we never sent\n        // However receiving a File() with empty bytes is \"common\".\n        // See #658, #759 and #958. They seem to happen in a container\n        // which contain the real response right after.\n        try {\n          var reader = new extensions_1.BinaryReader(RPCResult.body);\n          if (!(reader.tgReadObject() instanceof tl_1.Api.upload.File)) {\n            throw new Error(\"Not an upload.File\");\n          }\n        } catch (e) {\n          this._log.error(e);\n          if (e instanceof errors_1.TypeNotFoundError) {\n            this._log.info(\"Received response without parent request: \".concat(RPCResult.body));\n            return;\n          } else {\n            throw e;\n          }\n        }\n        return;\n      }\n      if (RPCResult.error && state.msgId) {\n        var error = (0, errors_1.RPCMessageToError)(RPCResult.error, state.request);\n        this._sendQueue.append(new RequestState_1.RequestState(new tl_1.Api.MsgsAck({\n          msgIds: [state.msgId]\n        })));\n        state.reject(error);\n      } else {\n        try {\n          var _reader = new extensions_1.BinaryReader(RPCResult.body);\n          var read = state.request.readResult(_reader);\n          state.resolve(read);\n        } catch (e) {\n          state.reject(e);\n        }\n      }\n    }\n    /**\r\n     * Processes the inner messages of a container with many of them:\r\n     * msg_container#73f1f8dc messages:vector<%Message> = MessageContainer;\r\n     * @param message\r\n     * @returns {Promise<void>}\r\n     * @private\r\n     */\n  }, {\n    key: \"_handleContainer\",\n    value: function () {\n      var _handleContainer2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(message) {\n        var _iterator7, _step7, innerMessage;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              this._log.debug(\"Handling container\");\n              _iterator7 = _createForOfIteratorHelper(message.obj.messages);\n              _context8.prev = 2;\n              _iterator7.s();\n            case 4:\n              if ((_step7 = _iterator7.n()).done) {\n                _context8.next = 10;\n                break;\n              }\n              innerMessage = _step7.value;\n              _context8.next = 8;\n              return this._processMessage(innerMessage);\n            case 8:\n              _context8.next = 4;\n              break;\n            case 10:\n              _context8.next = 15;\n              break;\n            case 12:\n              _context8.prev = 12;\n              _context8.t0 = _context8[\"catch\"](2);\n              _iterator7.e(_context8.t0);\n            case 15:\n              _context8.prev = 15;\n              _iterator7.f();\n              return _context8.finish(15);\n            case 18:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, this, [[2, 12, 15, 18]]);\n      }));\n      function _handleContainer(_x4) {\n        return _handleContainer2.apply(this, arguments);\n      }\n      return _handleContainer;\n    }()\n    /**\r\n     * Unpacks the data from a gzipped object and processes it:\r\n     * gzip_packed#3072cfa1 packed_data:bytes = Object;\r\n     * @param message\r\n     * @returns {Promise<void>}\r\n     * @private\r\n     */\n  }, {\n    key: \"_handleGzipPacked\",\n    value: function () {\n      var _handleGzipPacked2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(message) {\n        var reader;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              this._log.debug(\"Handling gzipped data\");\n              reader = new extensions_1.BinaryReader(message.obj.data);\n              message.obj = reader.tgReadObject();\n              _context9.next = 5;\n              return this._processMessage(message);\n            case 5:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee9, this);\n      }));\n      function _handleGzipPacked(_x5) {\n        return _handleGzipPacked2.apply(this, arguments);\n      }\n      return _handleGzipPacked;\n    }()\n  }, {\n    key: \"_handleUpdate\",\n    value: function () {\n      var _handleUpdate2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(message) {\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              if (!(message.obj.SUBCLASS_OF_ID !== 0x8af52aac)) {\n                _context10.next = 3;\n                break;\n              }\n              // crc32(b'Updates')\n              this._log.warn(\"Note: \".concat(message.obj.className, \" is not an update, not dispatching it\"));\n              return _context10.abrupt(\"return\");\n            case 3:\n              this._log.debug(\"Handling update \" + message.obj.className);\n              if (this._updateCallback) {\n                this._updateCallback(this._client, message.obj);\n              }\n            case 5:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee10, this);\n      }));\n      function _handleUpdate(_x6) {\n        return _handleUpdate2.apply(this, arguments);\n      }\n      return _handleUpdate;\n    }()\n    /**\r\n     * Handles pong results, which don't come inside a ``RPCResult``\r\n     * but are still sent through a request:\r\n     * pong#347773c5 msg_id:long ping_id:long = Pong;\r\n     * @param message\r\n     * @returns {Promise<void>}\r\n     * @private\r\n     */\n  }, {\n    key: \"_handlePong\",\n    value: function () {\n      var _handlePong2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(message) {\n        var pong, state;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              pong = message.obj;\n              this._log.debug(\"Handling pong for message \".concat(pong.msgId));\n              state = this._pendingState.get(pong.msgId.toString());\n              this._pendingState.delete(pong.msgId.toString());\n              // Todo Check result\n              if (state) {\n                state.resolve(pong);\n              }\n            case 5:\n            case \"end\":\n              return _context11.stop();\n          }\n        }, _callee11, this);\n      }));\n      function _handlePong(_x7) {\n        return _handlePong2.apply(this, arguments);\n      }\n      return _handlePong;\n    }()\n    /**\r\n     * Corrects the currently used server salt to use the right value\r\n     * before enqueuing the rejected message to be re-sent:\r\n     * bad_server_salt#edab447b bad_msg_id:long bad_msg_seqno:int\r\n     * error_code:int new_server_salt:long = BadMsgNotification;\r\n     * @param message\r\n     * @returns {Promise<void>}\r\n     * @private\r\n     */\n  }, {\n    key: \"_handleBadServerSalt\",\n    value: function () {\n      var _handleBadServerSalt2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(message) {\n        var badSalt, states;\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) switch (_context12.prev = _context12.next) {\n            case 0:\n              badSalt = message.obj;\n              this._log.debug(\"Handling bad salt for message \".concat(badSalt.badMsgId));\n              this._state.salt = badSalt.newServerSalt;\n              states = this._popStates(badSalt.badMsgId);\n              this._sendQueue.extend(states);\n              this._log.debug(\"\".concat(states.length, \" message(s) will be resent\"));\n            case 6:\n            case \"end\":\n              return _context12.stop();\n          }\n        }, _callee12, this);\n      }));\n      function _handleBadServerSalt(_x8) {\n        return _handleBadServerSalt2.apply(this, arguments);\n      }\n      return _handleBadServerSalt;\n    }()\n    /**\r\n     * Adjusts the current state to be correct based on the\r\n     * received bad message notification whenever possible:\r\n     * bad_msg_notification#a7eff811 bad_msg_id:long bad_msg_seqno:int\r\n     * error_code:int = BadMsgNotification;\r\n     * @param message\r\n     * @returns {Promise<void>}\r\n     * @private\r\n     */\n  }, {\n    key: \"_handleBadNotification\",\n    value: function () {\n      var _handleBadNotification2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(message) {\n        var badMsg, states, to, _iterator8, _step8, state;\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) switch (_context13.prev = _context13.next) {\n            case 0:\n              badMsg = message.obj;\n              states = this._popStates(badMsg.badMsgId);\n              this._log.debug(\"Handling bad msg \".concat(JSON.stringify(badMsg)));\n              if (![16, 17].includes(badMsg.errorCode)) {\n                _context13.next = 8;\n                break;\n              }\n              // Sent msg_id too low or too high (respectively).\n              // Use the current msg_id to determine the right time offset.\n              to = this._state.updateTimeOffset((0, big_integer_1.default)(message.msgId));\n              this._log.info(\"System clock is wrong, set time offset to \".concat(to, \"s\"));\n              _context13.next = 19;\n              break;\n            case 8:\n              if (!(badMsg.errorCode === 32)) {\n                _context13.next = 12;\n                break;\n              }\n              // msg_seqno too low, so just pump it up by some \"large\" amount\n              // TODO A better fix would be to start with a new fresh session ID\n              this._state._sequence += 64;\n              _context13.next = 19;\n              break;\n            case 12:\n              if (!(badMsg.errorCode === 33)) {\n                _context13.next = 16;\n                break;\n              }\n              // msg_seqno too high never seems to happen but just in case\n              this._state._sequence -= 16;\n              _context13.next = 19;\n              break;\n            case 16:\n              _iterator8 = _createForOfIteratorHelper(states);\n              try {\n                for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                  state = _step8.value;\n                  state.reject(new errors_1.BadMessageError(state.request, badMsg.errorCode));\n                }\n              } catch (err) {\n                _iterator8.e(err);\n              } finally {\n                _iterator8.f();\n              }\n              return _context13.abrupt(\"return\");\n            case 19:\n              // Messages are to be re-sent once we've corrected the issue\n              this._sendQueue.extend(states);\n              this._log.debug(\"\".concat(states.length, \" messages will be resent due to bad msg\"));\n            case 21:\n            case \"end\":\n              return _context13.stop();\n          }\n        }, _callee13, this);\n      }));\n      function _handleBadNotification(_x9) {\n        return _handleBadNotification2.apply(this, arguments);\n      }\n      return _handleBadNotification;\n    }()\n    /**\r\n     * Updates the current status with the received detailed information:\r\n     * msg_detailed_info#276d3ec6 msg_id:long answer_msg_id:long\r\n     * bytes:int status:int = MsgDetailedInfo;\r\n     * @param message\r\n     * @returns {Promise<void>}\r\n     * @private\r\n     */\n  }, {\n    key: \"_handleDetailedInfo\",\n    value: function () {\n      var _handleDetailedInfo2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(message) {\n        var msgId;\n        return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n          while (1) switch (_context14.prev = _context14.next) {\n            case 0:\n              // TODO https://goo.gl/VvpCC6\n              msgId = message.obj.answerMsgId;\n              this._log.debug(\"Handling detailed info for message \".concat(msgId));\n              this._pendingAck.add(msgId);\n            case 3:\n            case \"end\":\n              return _context14.stop();\n          }\n        }, _callee14, this);\n      }));\n      function _handleDetailedInfo(_x10) {\n        return _handleDetailedInfo2.apply(this, arguments);\n      }\n      return _handleDetailedInfo;\n    }()\n    /**\r\n     * Updates the current status with the received detailed information:\r\n     * msg_new_detailed_info#809db6df answer_msg_id:long\r\n     * bytes:int status:int = MsgDetailedInfo;\r\n     * @param message\r\n     * @returns {Promise<void>}\r\n     * @private\r\n     */\n  }, {\n    key: \"_handleNewDetailedInfo\",\n    value: function () {\n      var _handleNewDetailedInfo2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(message) {\n        var msgId;\n        return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n          while (1) switch (_context15.prev = _context15.next) {\n            case 0:\n              // TODO https://goo.gl/VvpCC6\n              msgId = message.obj.answerMsgId;\n              this._log.debug(\"Handling new detailed info for message \".concat(msgId));\n              this._pendingAck.add(msgId);\n            case 3:\n            case \"end\":\n              return _context15.stop();\n          }\n        }, _callee15, this);\n      }));\n      function _handleNewDetailedInfo(_x11) {\n        return _handleNewDetailedInfo2.apply(this, arguments);\n      }\n      return _handleNewDetailedInfo;\n    }()\n    /**\r\n     * Updates the current status with the received session information:\r\n     * new_session_created#9ec20908 first_msg_id:long unique_id:long\r\n     * server_salt:long = NewSession;\r\n     * @param message\r\n     * @returns {Promise<void>}\r\n     * @private\r\n     */\n  }, {\n    key: \"_handleNewSessionCreated\",\n    value: function () {\n      var _handleNewSessionCreated2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(message) {\n        return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n          while (1) switch (_context16.prev = _context16.next) {\n            case 0:\n              // TODO https://goo.gl/LMyN7A\n              this._log.debug(\"Handling new session created\");\n              this._state.salt = message.obj.serverSalt;\n            case 2:\n            case \"end\":\n              return _context16.stop();\n          }\n        }, _callee16, this);\n      }));\n      function _handleNewSessionCreated(_x12) {\n        return _handleNewSessionCreated2.apply(this, arguments);\n      }\n      return _handleNewSessionCreated;\n    }()\n    /**\r\n     * Handles a server acknowledge about our messages. Normally\r\n     * these can be ignored except in the case of ``auth.logOut``:\r\n     *\r\n     *     auth.logOut#5717da40 = Bool;\r\n     *\r\n     * Telegram doesn't seem to send its result so we need to confirm\r\n     * it manually. No other request is known to have this behaviour.\r\n       * Since the ID of sent messages consisting of a container is\r\n     * never returned (unless on a bad notification), this method\r\n     * also removes containers messages when any of their inner\r\n     * messages are acknowledged.\r\n       * @param message\r\n     * @returns {Promise<void>}\r\n     * @private\r\n     */\n  }, {\n    key: \"_handleAck\",\n    value: function () {\n      var _handleAck2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(message) {\n        var ack, _iterator9, _step9, msgId, state;\n        return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n          while (1) switch (_context17.prev = _context17.next) {\n            case 0:\n              ack = message.obj;\n              this._log.debug(\"Handling acknowledge for \".concat(ack.msgIds));\n              _iterator9 = _createForOfIteratorHelper(ack.msgIds);\n              try {\n                for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                  msgId = _step9.value;\n                  state = this._pendingState.get(msgId);\n                  if (state && state.request instanceof tl_1.Api.auth.LogOut) {\n                    this._pendingState.delete(msgId);\n                    state.resolve(true);\n                  }\n                }\n              } catch (err) {\n                _iterator9.e(err);\n              } finally {\n                _iterator9.f();\n              }\n            case 4:\n            case \"end\":\n              return _context17.stop();\n          }\n        }, _callee17, this);\n      }));\n      function _handleAck(_x13) {\n        return _handleAck2.apply(this, arguments);\n      }\n      return _handleAck;\n    }()\n    /**\r\n     * Handles future salt results, which don't come inside a\r\n     * ``rpc_result`` but are still sent through a request:\r\n     *     future_salts#ae500895 req_msg_id:long now:int\r\n     *     salts:vector<future_salt> = FutureSalts;\r\n     * @param message\r\n     * @returns {Promise<void>}\r\n     * @private\r\n     */\n  }, {\n    key: \"_handleFutureSalts\",\n    value: function () {\n      var _handleFutureSalts2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(message) {\n        var state;\n        return _regeneratorRuntime().wrap(function _callee18$(_context18) {\n          while (1) switch (_context18.prev = _context18.next) {\n            case 0:\n              // TODO save these salts and automatically adjust to the\n              // correct one whenever the salt in use expires.\n              this._log.debug(\"Handling future salts for message \".concat(message.msgId));\n              state = this._pendingState.get(message.msgId.toString());\n              if (state) {\n                this._pendingState.delete(message.msgId.toString());\n                state.resolve(message.obj);\n              }\n            case 3:\n            case \"end\":\n              return _context18.stop();\n          }\n        }, _callee18, this);\n      }));\n      function _handleFutureSalts(_x14) {\n        return _handleFutureSalts2.apply(this, arguments);\n      }\n      return _handleFutureSalts;\n    }()\n    /**\r\n     * Handles both :tl:`MsgsStateReq` and :tl:`MsgResendReq` by\r\n     * enqueuing a :tl:`MsgsStateInfo` to be sent at a later point.\r\n     * @param message\r\n     * @returns {Promise<void>}\r\n     * @private\r\n     */\n  }, {\n    key: \"_handleStateForgotten\",\n    value: function () {\n      var _handleStateForgotten2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(message) {\n        return _regeneratorRuntime().wrap(function _callee19$(_context19) {\n          while (1) switch (_context19.prev = _context19.next) {\n            case 0:\n              this._sendQueue.append(new RequestState_1.RequestState(new tl_1.Api.MsgsStateInfo({\n                reqMsgId: message.msgId,\n                info: String.fromCharCode(1).repeat(message.obj.msgIds)\n              })));\n            case 1:\n            case \"end\":\n              return _context19.stop();\n          }\n        }, _callee19, this);\n      }));\n      function _handleStateForgotten(_x15) {\n        return _handleStateForgotten2.apply(this, arguments);\n      }\n      return _handleStateForgotten;\n    }()\n    /**\r\n     * Handles :tl:`MsgsAllInfo` by doing nothing (yet).\r\n     * @param message\r\n     * @returns {Promise<void>}\r\n     * @private\r\n     */\n  }, {\n    key: \"_handleMsgAll\",\n    value: function () {\n      var _handleMsgAll2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(message) {\n        return _regeneratorRuntime().wrap(function _callee20$(_context20) {\n          while (1) switch (_context20.prev = _context20.next) {\n            case 0:\n            case \"end\":\n              return _context20.stop();\n          }\n        }, _callee20);\n      }));\n      function _handleMsgAll(_x16) {\n        return _handleMsgAll2.apply(this, arguments);\n      }\n      return _handleMsgAll;\n    }()\n  }, {\n    key: \"_reconnect\",\n    value: function () {\n      var _reconnect2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21(lastError) {\n        var attempt, ok;\n        return _regeneratorRuntime().wrap(function _callee21$(_context21) {\n          while (1) switch (_context21.prev = _context21.next) {\n            case 0:\n              this._log.debug(\"Closing current connection...\");\n              _context21.next = 3;\n              return this._connection.disconnect();\n            case 3:\n              this._cancelLoops();\n              this._reconnecting = false;\n              this._state.reset();\n              ok = true;\n              attempt = 0;\n            case 8:\n              if (!(attempt < this._retries)) {\n                _context21.next = 43;\n                break;\n              }\n              _context21.prev = 9;\n              _context21.next = 12;\n              return this._connect();\n            case 12:\n              _context21.next = 14;\n              return (0, Helpers_1.sleep)(1000);\n            case 14:\n              this._sendQueue.extend(_toConsumableArray(this._pendingState.values()));\n              this._pendingState.clear();\n              if (this._autoReconnectCallback) {\n                this._autoReconnectCallback();\n              }\n              return _context21.abrupt(\"break\", 43);\n            case 20:\n              _context21.prev = 20;\n              _context21.t0 = _context21[\"catch\"](9);\n              if (attempt == this._retries - 1) {\n                ok = false;\n              }\n              if (!(_context21.t0 instanceof errors_1.InvalidBufferError)) {\n                _context21.next = 36;\n                break;\n              }\n              if (!(_context21.t0.code === 404)) {\n                _context21.next = 35;\n                break;\n              }\n              this._log.warn(\"Broken authorization key for dc \".concat(this._dcId, \"; resetting\"));\n              _context21.next = 28;\n              return this.authKey.setKey(undefined);\n            case 28:\n              if (!this._authKeyCallback) {\n                _context21.next = 31;\n                break;\n              }\n              _context21.next = 31;\n              return this._authKeyCallback(undefined);\n            case 31:\n              ok = false;\n              return _context21.abrupt(\"break\", 43);\n            case 35:\n              // this happens sometimes when telegram is having some internal issues.\n              // since the data we sent and received is probably wrong now.\n              this._log.warn(\"Invalid buffer \".concat(_context21.t0.code, \" for dc \").concat(this._dcId));\n            case 36:\n              this._log.error(\"Unexpected exception reconnecting on attempt \".concat(attempt));\n              _context21.next = 39;\n              return (0, Helpers_1.sleep)(this._delay);\n            case 39:\n              lastError = _context21.t0;\n            case 40:\n              attempt++;\n              _context21.next = 8;\n              break;\n            case 43:\n              if (ok) {\n                _context21.next = 47;\n                break;\n              }\n              this._log.error(\"Automatic reconnection failed \".concat(attempt, \" time(s)\"));\n              _context21.next = 47;\n              return this._disconnect(lastError ? lastError : undefined);\n            case 47:\n            case \"end\":\n              return _context21.stop();\n          }\n        }, _callee21, this, [[9, 20]]);\n      }));\n      function _reconnect(_x17) {\n        return _reconnect2.apply(this, arguments);\n      }\n      return _reconnect;\n    }()\n  }, {\n    key: \"_tryConnect\",\n    value: function () {\n      var _tryConnect2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee22(attempt) {\n        return _regeneratorRuntime().wrap(function _callee22$(_context22) {\n          while (1) switch (_context22.prev = _context22.next) {\n            case 0:\n              _context22.prev = 0;\n              this._log.debug(\"Connection attempt \".concat(attempt, \"...\"));\n              _context22.next = 4;\n              return this._connection.connect();\n            case 4:\n              this._log.debug(\"Connection success!\");\n              return _context22.abrupt(\"return\", true);\n            case 8:\n              _context22.prev = 8;\n              _context22.t0 = _context22[\"catch\"](0);\n              this._log.warn(\"Attempt \".concat(attempt, \" at connecting failed\"));\n              if (this._log.canSend(Logger_1.LogLevel.ERROR)) {\n                console.error(_context22.t0);\n              }\n              _context22.next = 14;\n              return (0, Helpers_1.sleep)(this._delay);\n            case 14:\n              return _context22.abrupt(\"return\", false);\n            case 15:\n            case \"end\":\n              return _context22.stop();\n          }\n        }, _callee22, this, [[0, 8]]);\n      }));\n      function _tryConnect(_x18) {\n        return _tryConnect2.apply(this, arguments);\n      }\n      return _tryConnect;\n    }()\n  }, {\n    key: \"_tryGenAuthKey\",\n    value: function () {\n      var _tryGenAuthKey2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee23(attempt) {\n        var plain, res;\n        return _regeneratorRuntime().wrap(function _callee23$(_context23) {\n          while (1) switch (_context23.prev = _context23.next) {\n            case 0:\n              plain = new MTProtoPlainSender_1.MTProtoPlainSender(this._connection, this._log);\n              _context23.prev = 1;\n              this._log.debug(\"New auth_key attempt \".concat(attempt, \"...\"));\n              this._log.debug(\"New auth_key attempt ...\");\n              _context23.next = 6;\n              return (0, Authenticator_1.doAuthentication)(plain, this._log);\n            case 6:\n              res = _context23.sent;\n              this._log.debug(\"Generated new auth_key successfully\");\n              _context23.next = 10;\n              return this.authKey.setKey(res.authKey);\n            case 10:\n              this._state.timeOffset = res.timeOffset;\n              if (!this._authKeyCallback) {\n                _context23.next = 14;\n                break;\n              }\n              _context23.next = 14;\n              return this._authKeyCallback(this.authKey, this._dcId);\n            case 14:\n              this._log.debug(\"auth_key generation success!\");\n              return _context23.abrupt(\"return\", true);\n            case 18:\n              _context23.prev = 18;\n              _context23.t0 = _context23[\"catch\"](1);\n              this._log.warn(\"Attempt \".concat(attempt, \" at generating auth key failed\"));\n              if (this._log.canSend(Logger_1.LogLevel.ERROR)) {\n                console.error(_context23.t0);\n              }\n              return _context23.abrupt(\"return\", false);\n            case 23:\n            case \"end\":\n              return _context23.stop();\n          }\n        }, _callee23, this, [[1, 18]]);\n      }));\n      function _tryGenAuthKey(_x19) {\n        return _tryGenAuthKey2.apply(this, arguments);\n      }\n      return _tryGenAuthKey;\n    }()\n  }, {\n    key: \"_startReconnecting\",\n    value: function _startReconnecting(error) {\n      this._log.info(\"Starting reconnect...\");\n      if (this._userConnected && !this._reconnecting) {\n        this._reconnecting = true;\n        this._reconnect(error);\n      }\n    }\n  }]);\n  return MTProtoSender;\n}();\nexports.MTProtoSender = MTProtoSender;\nMTProtoSender.DEFAULT_OPTIONS = {\n  logger: null,\n  retries: Infinity,\n  delay: 2000,\n  autoReconnect: true,\n  connectTimeout: null,\n  authKeyCallback: null,\n  updateCallback: null,\n  autoReconnectCallback: null,\n  isMainSender: null,\n  senderCallback: null,\n  onConnectionBreak: undefined,\n  securityChecks: true\n};","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","MTProtoSender","AuthKey_1","require","MTProtoState_1","extensions_1","extensions_2","core_1","tl_1","big_integer_1","Helpers_1","RequestState_1","Authenticator_1","MTProtoPlainSender_1","errors_1","_1","Logger_1","async_mutex_1","real_cancellable_promise_1","authKey","opts","args","assign","DEFAULT_OPTIONS","_cancelSend","_connection","undefined","_log","logger","_dcId","dcId","_retries","retries","_delay","delay","_autoReconnect","autoReconnect","_connectTimeout","connectTimeout","_authKeyCallback","authKeyCallback","_updateCallback","updateCallback","_autoReconnectCallback","autoReconnectCallback","_isMainSender","isMainSender","_senderCallback","senderCallback","_client","client","_onConnectionBreak","onConnectionBreak","_securityChecks","securityChecks","_connectMutex","Mutex","userDisconnected","isConnecting","_authenticated","_userConnected","_reconnecting","_disconnected","_sendLoopHandle","_recvLoopHandle","AuthKey","_state","MTProtoState","_sendQueue","MessagePacker","_pendingState","Map","_pendingAck","Set","_lastAcks","_handlers","RPCResult","CONSTRUCTOR_ID","toString","_handleRPCResult","bind","MessageContainer","_handleContainer","GZIPPacked","_handleGzipPacked","Api","Pong","_handlePong","BadServerSalt","_handleBadServerSalt","BadMsgNotification","_handleBadNotification","MsgDetailedInfo","_handleDetailedInfo","MsgNewDetailedInfo","_handleNewDetailedInfo","NewSessionCreated","_handleNewSessionCreated","MsgsAck","_handleAck","FutureSalts","_handleFutureSalts","MsgsStateReq","_handleStateForgotten","MsgResendReq","MsgsAllInfo","_handleMsgAll","connection","acquire","release","info","_connect","_connected","_disconnect","error","request","Error","state","RequestState","append","promise","replace","socket","connected","attempt","_tryConnect","getKey","_tryGenAuthKey","warn","canSend","LogLevel","ERROR","console","disconnect","sleep","debug","_recvLoop","_sendLoop","size","values","result","reject","clear","_cancelLoops","cancellableRecvLoopPromise","cancel","ack","msgIds","Array","push","length","shift","get","res","data","batch","encryptMessageData","isArray","classType","set","msgId","s","send","_startReconnecting","pseudoCancellable","recv","body","Cancellation","decryptMessageData","message","TypeNotFoundError","invalidConstructorId","remaining","SecurityError","InvalidBufferError","code","UpdateConnectionState","broken","_processMessage","add","obj","handler","_handleUpdate","delete","toPop","containerId","equals","temp","x","reqMsgId","reader","BinaryReader","tgReadObject","upload","File","e","RPCMessageToError","read","readResult","resolve","messages","innerMessage","SUBCLASS_OF_ID","className","pong","badSalt","badMsgId","salt","newServerSalt","states","_popStates","extend","badMsg","JSON","stringify","includes","errorCode","to","updateTimeOffset","default","_sequence","BadMessageError","answerMsgId","serverSalt","auth","LogOut","MsgsStateInfo","String","fromCharCode","repeat","lastError","reset","ok","setKey","connect","plain","MTProtoPlainSender","doAuthentication","timeOffset","_reconnect","Infinity"],"sources":["C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/telegram/network/MTProtoSender.js"],"sourcesContent":["\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.MTProtoSender = void 0;\r\n/**\r\n * MTProto Mobile Protocol sender\r\n * (https://core.telegram.org/mtproto/description)\r\n * This class is responsible for wrapping requests into `TLMessage`'s,\r\n * sending them over the network and receiving them in a safe manner.\r\n *\r\n * Automatic reconnection due to temporary network issues is a concern\r\n * for this class as well, including retry of messages that could not\r\n * be sent successfully.\r\n *\r\n * A new authorization key will be generated on connection if no other\r\n * key exists yet.\r\n */\r\nconst AuthKey_1 = require(\"../crypto/AuthKey\");\r\nconst MTProtoState_1 = require(\"./MTProtoState\");\r\nconst extensions_1 = require(\"../extensions\");\r\nconst extensions_2 = require(\"../extensions\");\r\nconst core_1 = require(\"../tl/core\");\r\nconst tl_1 = require(\"../tl\");\r\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\r\nconst Helpers_1 = require(\"../Helpers\");\r\nconst RequestState_1 = require(\"./RequestState\");\r\nconst Authenticator_1 = require(\"./Authenticator\");\r\nconst MTProtoPlainSender_1 = require(\"./MTProtoPlainSender\");\r\nconst errors_1 = require(\"../errors\");\r\nconst _1 = require(\"./\");\r\nconst Logger_1 = require(\"../extensions/Logger\");\r\nconst async_mutex_1 = require(\"async-mutex\");\r\nconst real_cancellable_promise_1 = require(\"real-cancellable-promise\");\r\nclass MTProtoSender {\r\n    /**\r\n     * @param authKey\r\n     * @param opts\r\n     */\r\n    constructor(authKey, opts) {\r\n        const args = Object.assign(Object.assign({}, MTProtoSender.DEFAULT_OPTIONS), opts);\r\n        this._cancelSend = false;\r\n        this._connection = undefined;\r\n        this._log = args.logger;\r\n        this._dcId = args.dcId;\r\n        this._retries = args.retries;\r\n        this._delay = args.delay;\r\n        this._autoReconnect = args.autoReconnect;\r\n        this._connectTimeout = args.connectTimeout;\r\n        this._authKeyCallback = args.authKeyCallback;\r\n        this._updateCallback = args.updateCallback;\r\n        this._autoReconnectCallback = args.autoReconnectCallback;\r\n        this._isMainSender = args.isMainSender;\r\n        this._senderCallback = args.senderCallback;\r\n        this._client = args.client;\r\n        this._onConnectionBreak = args.onConnectionBreak;\r\n        this._securityChecks = args.securityChecks;\r\n        this._connectMutex = new async_mutex_1.Mutex();\r\n        /**\r\n         * whether we disconnected ourself or telegram did it.\r\n         */\r\n        this.userDisconnected = false;\r\n        /**\r\n         * If a disconnection happens for any other reason and it\r\n         * was *not* user action then the pending messages won't\r\n         * be cleared but on explicit user disconnection all the\r\n         * pending futures should be cancelled.\r\n         */\r\n        this.isConnecting = false;\r\n        this._authenticated = false;\r\n        this._userConnected = false;\r\n        this._reconnecting = false;\r\n        this._disconnected = true;\r\n        /**\r\n         * We need to join the loops upon disconnection\r\n         */\r\n        this._sendLoopHandle = null;\r\n        this._recvLoopHandle = null;\r\n        /**\r\n         * Preserving the references of the AuthKey and state is important\r\n         */\r\n        this.authKey = authKey || new AuthKey_1.AuthKey();\r\n        this._state = new MTProtoState_1.MTProtoState(this.authKey, this._log, this._securityChecks);\r\n        /**\r\n         * Outgoing messages are put in a queue and sent in a batch.\r\n         * Note that here we're also storing their ``_RequestState``.\r\n         */\r\n        this._sendQueue = new extensions_2.MessagePacker(this._state, this._log);\r\n        /**\r\n         * Sent states are remembered until a response is received.\r\n         */\r\n        this._pendingState = new Map();\r\n        /**\r\n         * Responses must be acknowledged, and we can also batch these.\r\n         */\r\n        this._pendingAck = new Set();\r\n        /**\r\n         * Similar to pending_messages but only for the last acknowledges.\r\n         * These can't go in pending_messages because no acknowledge for them\r\n         * is received, but we may still need to resend their state on bad salts.\r\n         */\r\n        this._lastAcks = [];\r\n        /**\r\n         * Jump table from response ID to method that handles it\r\n         */\r\n        this._handlers = {\r\n            [core_1.RPCResult.CONSTRUCTOR_ID.toString()]: this._handleRPCResult.bind(this),\r\n            [core_1.MessageContainer.CONSTRUCTOR_ID.toString()]: this._handleContainer.bind(this),\r\n            [core_1.GZIPPacked.CONSTRUCTOR_ID.toString()]: this._handleGzipPacked.bind(this),\r\n            [tl_1.Api.Pong.CONSTRUCTOR_ID.toString()]: this._handlePong.bind(this),\r\n            [tl_1.Api.BadServerSalt.CONSTRUCTOR_ID.toString()]: this._handleBadServerSalt.bind(this),\r\n            [tl_1.Api.BadMsgNotification.CONSTRUCTOR_ID.toString()]: this._handleBadNotification.bind(this),\r\n            [tl_1.Api.MsgDetailedInfo.CONSTRUCTOR_ID.toString()]: this._handleDetailedInfo.bind(this),\r\n            [tl_1.Api.MsgNewDetailedInfo.CONSTRUCTOR_ID.toString()]: this._handleNewDetailedInfo.bind(this),\r\n            [tl_1.Api.NewSessionCreated.CONSTRUCTOR_ID.toString()]: this._handleNewSessionCreated.bind(this),\r\n            [tl_1.Api.MsgsAck.CONSTRUCTOR_ID.toString()]: this._handleAck.bind(this),\r\n            [tl_1.Api.FutureSalts.CONSTRUCTOR_ID.toString()]: this._handleFutureSalts.bind(this),\r\n            [tl_1.Api.MsgsStateReq.CONSTRUCTOR_ID.toString()]: this._handleStateForgotten.bind(this),\r\n            [tl_1.Api.MsgResendReq.CONSTRUCTOR_ID.toString()]: this._handleStateForgotten.bind(this),\r\n            [tl_1.Api.MsgsAllInfo.CONSTRUCTOR_ID.toString()]: this._handleMsgAll.bind(this),\r\n        };\r\n    }\r\n    set dcId(dcId) {\r\n        this._dcId = dcId;\r\n    }\r\n    get dcId() {\r\n        return this._dcId;\r\n    }\r\n    // Public API\r\n    /**\r\n     * Connects to the specified given connection using the given auth key.\r\n     */\r\n    async connect(connection) {\r\n        const release = await this._connectMutex.acquire();\r\n        try {\r\n            if (this._userConnected) {\r\n                this._log.info(\"User is already connected!\");\r\n                return false;\r\n            }\r\n            this._connection = connection;\r\n            await this._connect();\r\n            this._userConnected = true;\r\n            return true;\r\n        }\r\n        finally {\r\n            release();\r\n        }\r\n    }\r\n    isConnected() {\r\n        return this._userConnected;\r\n    }\r\n    _transportConnected() {\r\n        return (!this._reconnecting &&\r\n            this._connection &&\r\n            this._connection._connected);\r\n    }\r\n    /**\r\n     * Cleanly disconnects the instance from the network, cancels\r\n     * all pending requests, and closes the send and receive loops.\r\n     */\r\n    async disconnect() {\r\n        const release = await this._connectMutex.acquire();\r\n        try {\r\n            await this._disconnect();\r\n        }\r\n        catch (e) {\r\n            this._log.error(e);\r\n        }\r\n        finally {\r\n            release();\r\n        }\r\n    }\r\n    /**\r\n     *\r\n     This method enqueues the given request to be sent. Its send\r\n     state will be saved until a response arrives, and a ``Future``\r\n     that will be resolved when the response arrives will be returned:\r\n\r\n     .. code-block:: javascript\r\n\r\n     async def method():\r\n     # Sending (enqueued for the send loop)\r\n     future = sender.send(request)\r\n     # Receiving (waits for the receive loop to read the result)\r\n     result = await future\r\n\r\n     Designed like this because Telegram may send the response at\r\n     any point, and it can send other items while one waits for it.\r\n     Once the response for this future arrives, it is set with the\r\n     received result, quite similar to how a ``receive()`` call\r\n     would otherwise work.\r\n\r\n     Since the receiving part is \"built in\" the future, it's\r\n     impossible to await receive a result that was never sent.\r\n     * @param request\r\n     * @returns {RequestState}\r\n     */\r\n    send(request) {\r\n        if (!this._userConnected) {\r\n            throw new Error(\"Cannot send requests while disconnected. You need to call .connect()\");\r\n        }\r\n        const state = new RequestState_1.RequestState(request);\r\n        this._sendQueue.append(state);\r\n        return state.promise;\r\n    }\r\n    /**\r\n     * Performs the actual connection, retrying, generating the\r\n     * authorization key if necessary, and starting the send and\r\n     * receive loops.\r\n     * @returns {Promise<void>}\r\n     * @private\r\n     */\r\n    async _connect() {\r\n        this._log.info(\"Connecting to {0} using {1}\"\r\n            .replace(\"{0}\", this._connection.toString())\r\n            .replace(\"{1}\", this._connection.socket.toString()));\r\n        let connected = false;\r\n        for (let attempt = 0; attempt < this._retries; attempt++) {\r\n            if (!connected) {\r\n                connected = await this._tryConnect(attempt);\r\n                if (!connected) {\r\n                    continue;\r\n                }\r\n            }\r\n            if (!this.authKey.getKey()) {\r\n                try {\r\n                    if (!(await this._tryGenAuthKey(attempt))) {\r\n                        continue;\r\n                    }\r\n                }\r\n                catch (err) {\r\n                    this._log.warn(`Connection error ${attempt} during auth_key gen`);\r\n                    if (this._log.canSend(Logger_1.LogLevel.ERROR)) {\r\n                        console.error(err);\r\n                    }\r\n                    await this._connection.disconnect();\r\n                    connected = false;\r\n                    await (0, Helpers_1.sleep)(this._delay);\r\n                    continue;\r\n                }\r\n            }\r\n            else {\r\n                this._authenticated = true;\r\n                this._log.debug(\"Already have an auth key ...\");\r\n            }\r\n            break;\r\n        }\r\n        if (!connected) {\r\n            throw new Error(`Connection to telegram failed after ${this._retries} time(s)`);\r\n        }\r\n        if (!this.authKey.getKey()) {\r\n            const error = new Error(`auth key generation failed after ${this._retries} time(s)`);\r\n            await this._disconnect(error);\r\n            throw error;\r\n        }\r\n        this._userConnected = true;\r\n        this._log.debug(\"Starting receive loop\");\r\n        this._recvLoopHandle = this._recvLoop();\r\n        this._log.debug(\"Starting send loop\");\r\n        this._sendLoopHandle = this._sendLoop();\r\n        this._log.info(\"Connection to %s complete!\".replace(\"%s\", this._connection.toString()));\r\n    }\r\n    async _disconnect(error) {\r\n        if (!this._connection) {\r\n            this._log.info(\"Not disconnecting (already have no connection)\");\r\n            return;\r\n        }\r\n        this._log.info(\"Disconnecting from %s...\".replace(\"%s\", this._connection.toString()));\r\n        this._userConnected = false;\r\n        try {\r\n            this._log.debug(\"Closing current connection...\");\r\n            await this._connection.disconnect();\r\n        }\r\n        finally {\r\n            this._log.debug(`Cancelling ${this._pendingState.size} pending message(s)...`);\r\n            for (const state of this._pendingState.values()) {\r\n                if (error && !state.result) {\r\n                    state.reject(error);\r\n                }\r\n                else {\r\n                    state.reject(\"disconnected\");\r\n                }\r\n            }\r\n            this._pendingState.clear();\r\n            this._cancelLoops();\r\n            this._log.info(\"Disconnecting from %s complete!\".replace(\"%s\", this._connection.toString()));\r\n            this._connection = undefined;\r\n        }\r\n    }\r\n    _cancelLoops() {\r\n        this._cancelSend = true;\r\n        this.cancellableRecvLoopPromise.cancel();\r\n    }\r\n    /**\r\n     * This loop is responsible for popping items off the send\r\n     * queue, encrypting them, and sending them over the network.\r\n     * Besides `connect`, only this method ever sends data.\r\n     * @returns {Promise<void>}\r\n     * @private\r\n     */\r\n    async _sendLoop() {\r\n        this._cancelSend = false;\r\n        while (this._userConnected &&\r\n            !this._reconnecting &&\r\n            !this._cancelSend) {\r\n            if (this._pendingAck.size) {\r\n                const ack = new RequestState_1.RequestState(new tl_1.Api.MsgsAck({ msgIds: Array(...this._pendingAck) }));\r\n                this._sendQueue.append(ack);\r\n                this._lastAcks.push(ack);\r\n                if (this._lastAcks.length >= 10) {\r\n                    this._lastAcks.shift();\r\n                }\r\n                this._pendingAck.clear();\r\n            }\r\n            this._log.debug(\"Waiting for messages to send...\" + this._reconnecting);\r\n            // TODO Wait for the connection send queue to be empty?\r\n            // This means that while it's not empty we can wait for\r\n            // more messages to be added to the send queue.\r\n            const res = await this._sendQueue.get();\r\n            if (!res) {\r\n                continue;\r\n            }\r\n            let { data } = res;\r\n            const { batch } = res;\r\n            this._log.debug(`Encrypting ${batch.length} message(s) in ${data.length} bytes for sending`);\r\n            data = await this._state.encryptMessageData(data);\r\n            for (const state of batch) {\r\n                if (!Array.isArray(state)) {\r\n                    if (state.request.classType === \"request\") {\r\n                        this._pendingState.set(state.msgId.toString(), state);\r\n                    }\r\n                }\r\n                else {\r\n                    for (const s of state) {\r\n                        if (s.request.classType === \"request\") {\r\n                            this._pendingState.set(s.msgId.toString(), s);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            try {\r\n                await this._connection.send(data);\r\n            }\r\n            catch (e) {\r\n                this._log.error(e);\r\n                this._log.info(\"Connection closed while sending data\");\r\n                this._startReconnecting(e);\r\n                return;\r\n            }\r\n            this._log.debug(\"Encrypted messages put in a queue to be sent\");\r\n        }\r\n    }\r\n    async _recvLoop() {\r\n        let body;\r\n        let message;\r\n        while (this._userConnected && !this._reconnecting) {\r\n            this._log.debug(\"Receiving items from the network...\");\r\n            try {\r\n                this.cancellableRecvLoopPromise = (0, real_cancellable_promise_1.pseudoCancellable)(this._connection.recv());\r\n                body = await this.cancellableRecvLoopPromise;\r\n            }\r\n            catch (e) {\r\n                if (e instanceof real_cancellable_promise_1.Cancellation) {\r\n                    return;\r\n                }\r\n                this._log.error(e);\r\n                this._log.warn(\"Connection closed while receiving data...\");\r\n                this._startReconnecting(e);\r\n                return;\r\n            }\r\n            try {\r\n                message = await this._state.decryptMessageData(body);\r\n            }\r\n            catch (e) {\r\n                if (e instanceof errors_1.TypeNotFoundError) {\r\n                    // Received object which we don't know how to deserialize\r\n                    this._log.info(`Type ${e.invalidConstructorId} not found, remaining data ${e.remaining}`);\r\n                    continue;\r\n                }\r\n                else if (e instanceof errors_1.SecurityError) {\r\n                    // A step while decoding had the incorrect data. This message\r\n                    // should not be considered safe and it should be ignored.\r\n                    this._log.warn(`Security error while unpacking a received message: ${e}`);\r\n                    continue;\r\n                }\r\n                else if (e instanceof errors_1.InvalidBufferError) {\r\n                    // 404 means that the server has \"forgotten\" our auth key and we need to create a new one.\r\n                    if (e.code === 404) {\r\n                        this._log.warn(`Broken authorization key for dc ${this._dcId}; resetting`);\r\n                        if (this._updateCallback && this._isMainSender) {\r\n                            this._updateCallback(this._client, new _1.UpdateConnectionState(_1.UpdateConnectionState.broken));\r\n                        }\r\n                        else if (this._onConnectionBreak &&\r\n                            !this._isMainSender) {\r\n                            // Deletes the current sender from the object\r\n                            this._onConnectionBreak(this._dcId);\r\n                        }\r\n                        await this._disconnect(e);\r\n                    }\r\n                    else {\r\n                        // this happens sometimes when telegram is having some internal issues.\r\n                        // reconnecting should be enough usually\r\n                        // since the data we sent and received is probably wrong now.\r\n                        this._log.warn(`Invalid buffer ${e.code} for dc ${this._dcId}`);\r\n                        this._startReconnecting(e);\r\n                    }\r\n                    return;\r\n                }\r\n                else {\r\n                    this._log.error(\"Unhandled error while receiving data\");\r\n                    this._log.error(e);\r\n                    this._startReconnecting(e);\r\n                    return;\r\n                }\r\n            }\r\n            try {\r\n                await this._processMessage(message);\r\n            }\r\n            catch (e) {\r\n                this._log.error(\"Unhandled error while processing data\");\r\n                this._log.error(e);\r\n            }\r\n        }\r\n    }\r\n    // Response Handlers\r\n    /**\r\n     * Adds the given message to the list of messages that must be\r\n     * acknowledged and dispatches control to different ``_handle_*``\r\n     * method based on its type.\r\n     * @param message\r\n     * @returns {Promise<void>}\r\n     * @private\r\n     */\r\n    async _processMessage(message) {\r\n        this._pendingAck.add(message.msgId);\r\n        message.obj = await message.obj;\r\n        let handler = this._handlers[message.obj.CONSTRUCTOR_ID.toString()];\r\n        if (!handler) {\r\n            handler = this._handleUpdate.bind(this);\r\n        }\r\n        await handler(message);\r\n    }\r\n    /**\r\n     * Pops the states known to match the given ID from pending messages.\r\n     * This method should be used when the response isn't specific.\r\n     * @param msgId\r\n     * @returns {*[]}\r\n     * @private\r\n     */\r\n    _popStates(msgId) {\r\n        let state = this._pendingState.get(msgId.toString());\r\n        if (state) {\r\n            this._pendingState.delete(msgId.toString());\r\n            return [state];\r\n        }\r\n        const toPop = [];\r\n        for (const state of this._pendingState.values()) {\r\n            if (state.containerId && state.containerId.equals(msgId)) {\r\n                toPop.push(state.msgId);\r\n            }\r\n        }\r\n        if (toPop.length) {\r\n            const temp = [];\r\n            for (const x of toPop) {\r\n                temp.push(this._pendingState.get(x.toString()));\r\n                this._pendingState.delete(x.toString());\r\n            }\r\n            return temp;\r\n        }\r\n        for (const ack of this._lastAcks) {\r\n            if (ack.msgId === msgId) {\r\n                return [ack];\r\n            }\r\n        }\r\n        return [];\r\n    }\r\n    /**\r\n     * Handles the result for Remote Procedure Calls:\r\n     * rpc_result#f35c6d01 req_msg_id:long result:bytes = RpcResult;\r\n     * This is where the future results for sent requests are set.\r\n     * @param message\r\n     * @returns {Promise<void>}\r\n     * @private\r\n     */\r\n    _handleRPCResult(message) {\r\n        const RPCResult = message.obj;\r\n        const state = this._pendingState.get(RPCResult.reqMsgId.toString());\r\n        if (state) {\r\n            this._pendingState.delete(RPCResult.reqMsgId.toString());\r\n        }\r\n        this._log.debug(`Handling RPC result for message ${RPCResult.reqMsgId}`);\r\n        if (!state) {\r\n            // TODO We should not get responses to things we never sent\r\n            // However receiving a File() with empty bytes is \"common\".\r\n            // See #658, #759 and #958. They seem to happen in a container\r\n            // which contain the real response right after.\r\n            try {\r\n                const reader = new extensions_1.BinaryReader(RPCResult.body);\r\n                if (!(reader.tgReadObject() instanceof tl_1.Api.upload.File)) {\r\n                    throw new Error(\"Not an upload.File\");\r\n                }\r\n            }\r\n            catch (e) {\r\n                this._log.error(e);\r\n                if (e instanceof errors_1.TypeNotFoundError) {\r\n                    this._log.info(`Received response without parent request: ${RPCResult.body}`);\r\n                    return;\r\n                }\r\n                else {\r\n                    throw e;\r\n                }\r\n            }\r\n            return;\r\n        }\r\n        if (RPCResult.error && state.msgId) {\r\n            const error = (0, errors_1.RPCMessageToError)(RPCResult.error, state.request);\r\n            this._sendQueue.append(new RequestState_1.RequestState(new tl_1.Api.MsgsAck({ msgIds: [state.msgId] })));\r\n            state.reject(error);\r\n        }\r\n        else {\r\n            try {\r\n                const reader = new extensions_1.BinaryReader(RPCResult.body);\r\n                const read = state.request.readResult(reader);\r\n                state.resolve(read);\r\n            }\r\n            catch (e) {\r\n                state.reject(e);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Processes the inner messages of a container with many of them:\r\n     * msg_container#73f1f8dc messages:vector<%Message> = MessageContainer;\r\n     * @param message\r\n     * @returns {Promise<void>}\r\n     * @private\r\n     */\r\n    async _handleContainer(message) {\r\n        this._log.debug(\"Handling container\");\r\n        for (const innerMessage of message.obj.messages) {\r\n            await this._processMessage(innerMessage);\r\n        }\r\n    }\r\n    /**\r\n     * Unpacks the data from a gzipped object and processes it:\r\n     * gzip_packed#3072cfa1 packed_data:bytes = Object;\r\n     * @param message\r\n     * @returns {Promise<void>}\r\n     * @private\r\n     */\r\n    async _handleGzipPacked(message) {\r\n        this._log.debug(\"Handling gzipped data\");\r\n        const reader = new extensions_1.BinaryReader(message.obj.data);\r\n        message.obj = reader.tgReadObject();\r\n        await this._processMessage(message);\r\n    }\r\n    async _handleUpdate(message) {\r\n        if (message.obj.SUBCLASS_OF_ID !== 0x8af52aac) {\r\n            // crc32(b'Updates')\r\n            this._log.warn(`Note: ${message.obj.className} is not an update, not dispatching it`);\r\n            return;\r\n        }\r\n        this._log.debug(\"Handling update \" + message.obj.className);\r\n        if (this._updateCallback) {\r\n            this._updateCallback(this._client, message.obj);\r\n        }\r\n    }\r\n    /**\r\n     * Handles pong results, which don't come inside a ``RPCResult``\r\n     * but are still sent through a request:\r\n     * pong#347773c5 msg_id:long ping_id:long = Pong;\r\n     * @param message\r\n     * @returns {Promise<void>}\r\n     * @private\r\n     */\r\n    async _handlePong(message) {\r\n        const pong = message.obj;\r\n        this._log.debug(`Handling pong for message ${pong.msgId}`);\r\n        const state = this._pendingState.get(pong.msgId.toString());\r\n        this._pendingState.delete(pong.msgId.toString());\r\n        // Todo Check result\r\n        if (state) {\r\n            state.resolve(pong);\r\n        }\r\n    }\r\n    /**\r\n     * Corrects the currently used server salt to use the right value\r\n     * before enqueuing the rejected message to be re-sent:\r\n     * bad_server_salt#edab447b bad_msg_id:long bad_msg_seqno:int\r\n     * error_code:int new_server_salt:long = BadMsgNotification;\r\n     * @param message\r\n     * @returns {Promise<void>}\r\n     * @private\r\n     */\r\n    async _handleBadServerSalt(message) {\r\n        const badSalt = message.obj;\r\n        this._log.debug(`Handling bad salt for message ${badSalt.badMsgId}`);\r\n        this._state.salt = badSalt.newServerSalt;\r\n        const states = this._popStates(badSalt.badMsgId);\r\n        this._sendQueue.extend(states);\r\n        this._log.debug(`${states.length} message(s) will be resent`);\r\n    }\r\n    /**\r\n     * Adjusts the current state to be correct based on the\r\n     * received bad message notification whenever possible:\r\n     * bad_msg_notification#a7eff811 bad_msg_id:long bad_msg_seqno:int\r\n     * error_code:int = BadMsgNotification;\r\n     * @param message\r\n     * @returns {Promise<void>}\r\n     * @private\r\n     */\r\n    async _handleBadNotification(message) {\r\n        const badMsg = message.obj;\r\n        const states = this._popStates(badMsg.badMsgId);\r\n        this._log.debug(`Handling bad msg ${JSON.stringify(badMsg)}`);\r\n        if ([16, 17].includes(badMsg.errorCode)) {\r\n            // Sent msg_id too low or too high (respectively).\r\n            // Use the current msg_id to determine the right time offset.\r\n            const to = this._state.updateTimeOffset((0, big_integer_1.default)(message.msgId));\r\n            this._log.info(`System clock is wrong, set time offset to ${to}s`);\r\n        }\r\n        else if (badMsg.errorCode === 32) {\r\n            // msg_seqno too low, so just pump it up by some \"large\" amount\r\n            // TODO A better fix would be to start with a new fresh session ID\r\n            this._state._sequence += 64;\r\n        }\r\n        else if (badMsg.errorCode === 33) {\r\n            // msg_seqno too high never seems to happen but just in case\r\n            this._state._sequence -= 16;\r\n        }\r\n        else {\r\n            for (const state of states) {\r\n                state.reject(new errors_1.BadMessageError(state.request, badMsg.errorCode));\r\n            }\r\n            return;\r\n        }\r\n        // Messages are to be re-sent once we've corrected the issue\r\n        this._sendQueue.extend(states);\r\n        this._log.debug(`${states.length} messages will be resent due to bad msg`);\r\n    }\r\n    /**\r\n     * Updates the current status with the received detailed information:\r\n     * msg_detailed_info#276d3ec6 msg_id:long answer_msg_id:long\r\n     * bytes:int status:int = MsgDetailedInfo;\r\n     * @param message\r\n     * @returns {Promise<void>}\r\n     * @private\r\n     */\r\n    async _handleDetailedInfo(message) {\r\n        // TODO https://goo.gl/VvpCC6\r\n        const msgId = message.obj.answerMsgId;\r\n        this._log.debug(`Handling detailed info for message ${msgId}`);\r\n        this._pendingAck.add(msgId);\r\n    }\r\n    /**\r\n     * Updates the current status with the received detailed information:\r\n     * msg_new_detailed_info#809db6df answer_msg_id:long\r\n     * bytes:int status:int = MsgDetailedInfo;\r\n     * @param message\r\n     * @returns {Promise<void>}\r\n     * @private\r\n     */\r\n    async _handleNewDetailedInfo(message) {\r\n        // TODO https://goo.gl/VvpCC6\r\n        const msgId = message.obj.answerMsgId;\r\n        this._log.debug(`Handling new detailed info for message ${msgId}`);\r\n        this._pendingAck.add(msgId);\r\n    }\r\n    /**\r\n     * Updates the current status with the received session information:\r\n     * new_session_created#9ec20908 first_msg_id:long unique_id:long\r\n     * server_salt:long = NewSession;\r\n     * @param message\r\n     * @returns {Promise<void>}\r\n     * @private\r\n     */\r\n    async _handleNewSessionCreated(message) {\r\n        // TODO https://goo.gl/LMyN7A\r\n        this._log.debug(\"Handling new session created\");\r\n        this._state.salt = message.obj.serverSalt;\r\n    }\r\n    /**\r\n     * Handles a server acknowledge about our messages. Normally\r\n     * these can be ignored except in the case of ``auth.logOut``:\r\n     *\r\n     *     auth.logOut#5717da40 = Bool;\r\n     *\r\n     * Telegram doesn't seem to send its result so we need to confirm\r\n     * it manually. No other request is known to have this behaviour.\r\n\r\n     * Since the ID of sent messages consisting of a container is\r\n     * never returned (unless on a bad notification), this method\r\n     * also removes containers messages when any of their inner\r\n     * messages are acknowledged.\r\n\r\n     * @param message\r\n     * @returns {Promise<void>}\r\n     * @private\r\n     */\r\n    async _handleAck(message) {\r\n        const ack = message.obj;\r\n        this._log.debug(`Handling acknowledge for ${ack.msgIds}`);\r\n        for (const msgId of ack.msgIds) {\r\n            const state = this._pendingState.get(msgId);\r\n            if (state && state.request instanceof tl_1.Api.auth.LogOut) {\r\n                this._pendingState.delete(msgId);\r\n                state.resolve(true);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Handles future salt results, which don't come inside a\r\n     * ``rpc_result`` but are still sent through a request:\r\n     *     future_salts#ae500895 req_msg_id:long now:int\r\n     *     salts:vector<future_salt> = FutureSalts;\r\n     * @param message\r\n     * @returns {Promise<void>}\r\n     * @private\r\n     */\r\n    async _handleFutureSalts(message) {\r\n        // TODO save these salts and automatically adjust to the\r\n        // correct one whenever the salt in use expires.\r\n        this._log.debug(`Handling future salts for message ${message.msgId}`);\r\n        const state = this._pendingState.get(message.msgId.toString());\r\n        if (state) {\r\n            this._pendingState.delete(message.msgId.toString());\r\n            state.resolve(message.obj);\r\n        }\r\n    }\r\n    /**\r\n     * Handles both :tl:`MsgsStateReq` and :tl:`MsgResendReq` by\r\n     * enqueuing a :tl:`MsgsStateInfo` to be sent at a later point.\r\n     * @param message\r\n     * @returns {Promise<void>}\r\n     * @private\r\n     */\r\n    async _handleStateForgotten(message) {\r\n        this._sendQueue.append(new RequestState_1.RequestState(new tl_1.Api.MsgsStateInfo({\r\n            reqMsgId: message.msgId,\r\n            info: String.fromCharCode(1).repeat(message.obj.msgIds),\r\n        })));\r\n    }\r\n    /**\r\n     * Handles :tl:`MsgsAllInfo` by doing nothing (yet).\r\n     * @param message\r\n     * @returns {Promise<void>}\r\n     * @private\r\n     */\r\n    async _handleMsgAll(message) { }\r\n    async _reconnect(lastError) {\r\n        this._log.debug(\"Closing current connection...\");\r\n        await this._connection.disconnect();\r\n        this._cancelLoops();\r\n        this._reconnecting = false;\r\n        this._state.reset();\r\n        let attempt;\r\n        let ok = true;\r\n        for (attempt = 0; attempt < this._retries; attempt++) {\r\n            try {\r\n                await this._connect();\r\n                await (0, Helpers_1.sleep)(1000);\r\n                this._sendQueue.extend([...this._pendingState.values()]);\r\n                this._pendingState.clear();\r\n                if (this._autoReconnectCallback) {\r\n                    this._autoReconnectCallback();\r\n                }\r\n                break;\r\n            }\r\n            catch (err) {\r\n                if (attempt == this._retries - 1) {\r\n                    ok = false;\r\n                }\r\n                if (err instanceof errors_1.InvalidBufferError) {\r\n                    if (err.code === 404) {\r\n                        this._log.warn(`Broken authorization key for dc ${this._dcId}; resetting`);\r\n                        await this.authKey.setKey(undefined);\r\n                        if (this._authKeyCallback) {\r\n                            await this._authKeyCallback(undefined);\r\n                        }\r\n                        ok = false;\r\n                        break;\r\n                    }\r\n                    else {\r\n                        // this happens sometimes when telegram is having some internal issues.\r\n                        // since the data we sent and received is probably wrong now.\r\n                        this._log.warn(`Invalid buffer ${err.code} for dc ${this._dcId}`);\r\n                    }\r\n                }\r\n                this._log.error(`Unexpected exception reconnecting on attempt ${attempt}`);\r\n                await (0, Helpers_1.sleep)(this._delay);\r\n                lastError = err;\r\n            }\r\n        }\r\n        if (!ok) {\r\n            this._log.error(`Automatic reconnection failed ${attempt} time(s)`);\r\n            await this._disconnect(lastError ? lastError : undefined);\r\n        }\r\n    }\r\n    async _tryConnect(attempt) {\r\n        try {\r\n            this._log.debug(`Connection attempt ${attempt}...`);\r\n            await this._connection.connect();\r\n            this._log.debug(\"Connection success!\");\r\n            return true;\r\n        }\r\n        catch (err) {\r\n            this._log.warn(`Attempt ${attempt} at connecting failed`);\r\n            if (this._log.canSend(Logger_1.LogLevel.ERROR)) {\r\n                console.error(err);\r\n            }\r\n            await (0, Helpers_1.sleep)(this._delay);\r\n            return false;\r\n        }\r\n    }\r\n    async _tryGenAuthKey(attempt) {\r\n        const plain = new MTProtoPlainSender_1.MTProtoPlainSender(this._connection, this._log);\r\n        try {\r\n            this._log.debug(`New auth_key attempt ${attempt}...`);\r\n            this._log.debug(\"New auth_key attempt ...\");\r\n            const res = await (0, Authenticator_1.doAuthentication)(plain, this._log);\r\n            this._log.debug(\"Generated new auth_key successfully\");\r\n            await this.authKey.setKey(res.authKey);\r\n            this._state.timeOffset = res.timeOffset;\r\n            if (this._authKeyCallback) {\r\n                await this._authKeyCallback(this.authKey, this._dcId);\r\n            }\r\n            this._log.debug(\"auth_key generation success!\");\r\n            return true;\r\n        }\r\n        catch (err) {\r\n            this._log.warn(`Attempt ${attempt} at generating auth key failed`);\r\n            if (this._log.canSend(Logger_1.LogLevel.ERROR)) {\r\n                console.error(err);\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n    _startReconnecting(error) {\r\n        this._log.info(`Starting reconnect...`);\r\n        if (this._userConnected && !this._reconnecting) {\r\n            this._reconnecting = true;\r\n            this._reconnect(error);\r\n        }\r\n    }\r\n}\r\nexports.MTProtoSender = MTProtoSender;\r\nMTProtoSender.DEFAULT_OPTIONS = {\r\n    logger: null,\r\n    retries: Infinity,\r\n    delay: 2000,\r\n    autoReconnect: true,\r\n    connectTimeout: null,\r\n    authKeyCallback: null,\r\n    updateCallback: null,\r\n    autoReconnectCallback: null,\r\n    isMainSender: null,\r\n    senderCallback: null,\r\n    onConnectionBreak: undefined,\r\n    securityChecks: true,\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}