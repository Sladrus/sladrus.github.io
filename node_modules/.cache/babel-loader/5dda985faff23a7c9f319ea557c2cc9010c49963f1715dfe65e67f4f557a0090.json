{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StringSession = void 0;\nvar buffer_1 = require(\"buffer/\");\nvar Memory_1 = require(\"./Memory\");\nvar extensions_1 = require(\"../extensions\");\nvar AuthKey_1 = require(\"../crypto/AuthKey\");\nvar CURRENT_VERSION = \"1\";\nvar StringSession = /*#__PURE__*/function (_Memory_1$MemorySessi) {\n  _inherits(StringSession, _Memory_1$MemorySessi);\n  var _super = _createSuper(StringSession);\n  /**\r\n   * This session file can be easily saved and loaded as a string. According\r\n   * to the initial design, it contains only the data that is necessary for\r\n   * successful connection and authentication, so takeout ID is not stored.\r\n     * It is thought to be used where you don't want to create any on-disk\r\n   * files but would still like to be able to save and load existing sessions\r\n   * by other means.\r\n     * You can use custom `encode` and `decode` functions, if present:\r\n     * `encode` definition must be ``function encode(value: Buffer) -> string:``.\r\n   * `decode` definition must be ``function decode(value: string) -> Buffer:``.\r\n   * @param session {string|null}\r\n   */\n  function StringSession(session) {\n    var _this;\n    _classCallCheck(this, StringSession);\n    _this = _super.call(this);\n    if (session) {\n      if (session[0] !== CURRENT_VERSION) {\n        throw new Error(\"Not a valid string\");\n      }\n      session = session.slice(1);\n      var r = StringSession.decode(session);\n      var reader = new extensions_1.BinaryReader(r);\n      _this._dcId = reader.read(1).readUInt8(0);\n      if (session.length == 352) {\n        // Telethon session\n        var ip_v4 = reader.read(4);\n        // TODO looks ugly smh\n        _this._serverAddress = ip_v4[0].toString() + \".\" + ip_v4[1].toString() + \".\" + ip_v4[2].toString() + \".\" + ip_v4[3].toString();\n      } else {\n        // TODO find a better of doing this\n        var serverAddressLen = reader.read(2).readInt16BE(0);\n        if (serverAddressLen > 100) {\n          reader.offset -= 2;\n          _this._serverAddress = reader.read(16).toString(\"hex\").match(/.{1,4}/g).map(function (val) {\n            return val.replace(/^0+/, \"\");\n          }).join(\":\").replace(/0000\\:/g, \":\").replace(/:{2,}/g, \"::\");\n        } else {\n          _this._serverAddress = reader.read(serverAddressLen).toString();\n        }\n      }\n      _this._port = reader.read(2).readInt16BE(0);\n      _this._key = reader.read(-1);\n    }\n    return _this;\n  }\n  /**\r\n   * @param x {Buffer}\r\n   * @returns {string}\r\n   */\n  _createClass(StringSession, [{\n    key: \"load\",\n    value: function () {\n      var _load = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!this._key) {\n                _context.next = 4;\n                break;\n              }\n              this._authKey = new AuthKey_1.AuthKey();\n              _context.next = 4;\n              return this._authKey.setKey(this._key);\n            case 4:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function load() {\n        return _load.apply(this, arguments);\n      }\n      return load;\n    }()\n  }, {\n    key: \"save\",\n    value: function save() {\n      if (!this.authKey || !this.serverAddress || !this.port) {\n        return \"\";\n      }\n      // TS is weird\n      var key = this.authKey.getKey();\n      if (!key) {\n        return \"\";\n      }\n      var dcBuffer = buffer_1.Buffer.from([this.dcId]);\n      var addressBuffer = buffer_1.Buffer.from(this.serverAddress);\n      var addressLengthBuffer = buffer_1.Buffer.alloc(2);\n      addressLengthBuffer.writeInt16BE(addressBuffer.length, 0);\n      var portBuffer = buffer_1.Buffer.alloc(2);\n      portBuffer.writeInt16BE(this.port, 0);\n      return CURRENT_VERSION + StringSession.encode(buffer_1.Buffer.concat([dcBuffer, addressLengthBuffer, addressBuffer, portBuffer, key]));\n    }\n  }], [{\n    key: \"encode\",\n    value: function encode(x) {\n      return x.toString(\"base64\");\n    }\n    /**\r\n     * @param x {string}\r\n     * @returns {Buffer}\r\n     */\n  }, {\n    key: \"decode\",\n    value: function decode(x) {\n      return buffer_1.Buffer.from(x, \"base64\");\n    }\n  }]);\n  return StringSession;\n}(Memory_1.MemorySession);\nexports.StringSession = StringSession;","map":{"version":3,"names":["Object","defineProperty","exports","value","StringSession","buffer_1","require","Memory_1","extensions_1","AuthKey_1","CURRENT_VERSION","session","Error","slice","r","decode","reader","BinaryReader","_dcId","read","readUInt8","length","ip_v4","_serverAddress","toString","serverAddressLen","readInt16BE","offset","match","map","val","replace","join","_port","_key","_authKey","AuthKey","setKey","authKey","serverAddress","port","key","getKey","dcBuffer","Buffer","from","dcId","addressBuffer","addressLengthBuffer","alloc","writeInt16BE","portBuffer","encode","concat","x","MemorySession"],"sources":["C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/telegram/sessions/StringSession.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.StringSession = void 0;\r\nconst buffer_1 = require(\"buffer/\");\r\nconst Memory_1 = require(\"./Memory\");\r\nconst extensions_1 = require(\"../extensions\");\r\nconst AuthKey_1 = require(\"../crypto/AuthKey\");\r\nconst CURRENT_VERSION = \"1\";\r\nclass StringSession extends Memory_1.MemorySession {\r\n    /**\r\n     * This session file can be easily saved and loaded as a string. According\r\n     * to the initial design, it contains only the data that is necessary for\r\n     * successful connection and authentication, so takeout ID is not stored.\r\n\r\n     * It is thought to be used where you don't want to create any on-disk\r\n     * files but would still like to be able to save and load existing sessions\r\n     * by other means.\r\n\r\n     * You can use custom `encode` and `decode` functions, if present:\r\n\r\n     * `encode` definition must be ``function encode(value: Buffer) -> string:``.\r\n     * `decode` definition must be ``function decode(value: string) -> Buffer:``.\r\n     * @param session {string|null}\r\n     */\r\n    constructor(session) {\r\n        super();\r\n        if (session) {\r\n            if (session[0] !== CURRENT_VERSION) {\r\n                throw new Error(\"Not a valid string\");\r\n            }\r\n            session = session.slice(1);\r\n            const r = StringSession.decode(session);\r\n            const reader = new extensions_1.BinaryReader(r);\r\n            this._dcId = reader.read(1).readUInt8(0);\r\n            if (session.length == 352) {\r\n                // Telethon session\r\n                const ip_v4 = reader.read(4);\r\n                // TODO looks ugly smh\r\n                this._serverAddress =\r\n                    ip_v4[0].toString() +\r\n                        \".\" +\r\n                        ip_v4[1].toString() +\r\n                        \".\" +\r\n                        ip_v4[2].toString() +\r\n                        \".\" +\r\n                        ip_v4[3].toString();\r\n            }\r\n            else {\r\n                // TODO find a better of doing this\r\n                const serverAddressLen = reader.read(2).readInt16BE(0);\r\n                if (serverAddressLen > 100) {\r\n                    reader.offset -= 2;\r\n                    this._serverAddress = reader\r\n                        .read(16)\r\n                        .toString(\"hex\")\r\n                        .match(/.{1,4}/g)\r\n                        .map((val) => val.replace(/^0+/, \"\"))\r\n                        .join(\":\")\r\n                        .replace(/0000\\:/g, \":\")\r\n                        .replace(/:{2,}/g, \"::\");\r\n                }\r\n                else {\r\n                    this._serverAddress = reader\r\n                        .read(serverAddressLen)\r\n                        .toString();\r\n                }\r\n            }\r\n            this._port = reader.read(2).readInt16BE(0);\r\n            this._key = reader.read(-1);\r\n        }\r\n    }\r\n    /**\r\n     * @param x {Buffer}\r\n     * @returns {string}\r\n     */\r\n    static encode(x) {\r\n        return x.toString(\"base64\");\r\n    }\r\n    /**\r\n     * @param x {string}\r\n     * @returns {Buffer}\r\n     */\r\n    static decode(x) {\r\n        return buffer_1.Buffer.from(x, \"base64\");\r\n    }\r\n    async load() {\r\n        if (this._key) {\r\n            this._authKey = new AuthKey_1.AuthKey();\r\n            await this._authKey.setKey(this._key);\r\n        }\r\n    }\r\n    save() {\r\n        if (!this.authKey || !this.serverAddress || !this.port) {\r\n            return \"\";\r\n        }\r\n        // TS is weird\r\n        const key = this.authKey.getKey();\r\n        if (!key) {\r\n            return \"\";\r\n        }\r\n        const dcBuffer = buffer_1.Buffer.from([this.dcId]);\r\n        const addressBuffer = buffer_1.Buffer.from(this.serverAddress);\r\n        const addressLengthBuffer = buffer_1.Buffer.alloc(2);\r\n        addressLengthBuffer.writeInt16BE(addressBuffer.length, 0);\r\n        const portBuffer = buffer_1.Buffer.alloc(2);\r\n        portBuffer.writeInt16BE(this.port, 0);\r\n        return (CURRENT_VERSION +\r\n            StringSession.encode(buffer_1.Buffer.concat([\r\n                dcBuffer,\r\n                addressLengthBuffer,\r\n                addressBuffer,\r\n                portBuffer,\r\n                key,\r\n            ])));\r\n    }\r\n}\r\nexports.StringSession = StringSession;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}