{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _toConsumableArray = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _regeneratorRuntime = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _get = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/get.js\").default;\nvar _getPrototypeOf = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/getPrototypeOf.js\").default;\nvar _inherits = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getDialogs = exports.iterDialogs = exports._DialogsIter = void 0;\nvar tl_1 = require(\"../tl\");\nvar requestIter_1 = require(\"../requestIter\");\nvar index_1 = require(\"../index\");\nvar dialog_1 = require(\"../tl/custom/dialog\");\nvar big_integer_1 = __importDefault(require(\"big-integer\"));\nvar Logger_1 = require(\"../extensions/Logger\");\nvar _MAX_CHUNK_SIZE = 100;\n/**\r\n Get the key to get messages from a dialog.\r\n\r\n We cannot just use the message ID because channels share message IDs,\r\n and the peer ID is required to distinguish between them. But it is not\r\n necessary in small group chats and private chats.\r\n * @param {Api.TypePeer} [peer] the dialog peer\r\n * @param {number} [messageId] the message id\r\n * @return {[number,number]} the channel id and message id\r\n */\nfunction _dialogMessageKey(peer, messageId) {\n  // can't use arrays as keys for map :( need to convert to string.\n  return \"\" + [peer instanceof tl_1.Api.PeerChannel ? peer.channelId : undefined, messageId];\n}\nvar _DialogsIter = /*#__PURE__*/function (_requestIter_1$Reques, _Symbol$asyncIterator) {\n  _inherits(_DialogsIter, _requestIter_1$Reques);\n  var _super = _createSuper(_DialogsIter);\n  function _DialogsIter() {\n    _classCallCheck(this, _DialogsIter);\n    return _super.apply(this, arguments);\n  }\n  _createClass(_DialogsIter, [{\n    key: \"_init\",\n    value: function () {\n      var _init2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {\n        var offsetDate, offsetId, offsetPeer, ignorePinned, ignoreMigrated, folder, dialogs;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              offsetDate = _ref.offsetDate, offsetId = _ref.offsetId, offsetPeer = _ref.offsetPeer, ignorePinned = _ref.ignorePinned, ignoreMigrated = _ref.ignoreMigrated, folder = _ref.folder;\n              this.request = new tl_1.Api.messages.GetDialogs({\n                offsetDate: offsetDate,\n                offsetId: offsetId,\n                offsetPeer: offsetPeer,\n                limit: 1,\n                hash: big_integer_1.default.zero,\n                excludePinned: ignorePinned,\n                folderId: folder\n              });\n              if (!(this.limit <= 0)) {\n                _context.next = 8;\n                break;\n              }\n              _context.next = 5;\n              return this.client.invoke(this.request);\n            case 5:\n              dialogs = _context.sent;\n              if (\"count\" in dialogs) {\n                this.total = dialogs.count;\n              } else {\n                this.total = dialogs.dialogs.length;\n              }\n              return _context.abrupt(\"return\", true);\n            case 8:\n              this.seen = new Set();\n              this.offsetDate = offsetDate;\n              this.ignoreMigrated = ignoreMigrated;\n            case 11:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function _init(_x) {\n        return _init2.apply(this, arguments);\n      }\n      return _init;\n    }()\n  }, {\n    key: _Symbol$asyncIterator,\n    value: function value() {\n      return _get(_getPrototypeOf(_DialogsIter.prototype), Symbol.asyncIterator, this).call(this);\n    }\n  }, {\n    key: \"_loadNextChunk\",\n    value: function () {\n      var _loadNextChunk2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var r, entities, messages, _i, _arr, entity, _iterator, _step, m, message, _iterator2, _step2, d, _message, date, peerId, cd, lastMessage, _iterator3, _step3, dialog;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!(!this.request || !this.seen || !this.buffer)) {\n                _context2.next = 2;\n                break;\n              }\n              return _context2.abrupt(\"return\");\n            case 2:\n              this.request.limit = Math.min(this.left, _MAX_CHUNK_SIZE);\n              _context2.next = 5;\n              return this.client.invoke(this.request);\n            case 5:\n              r = _context2.sent;\n              if (!(r instanceof tl_1.Api.messages.DialogsNotModified)) {\n                _context2.next = 8;\n                break;\n              }\n              return _context2.abrupt(\"return\");\n            case 8:\n              if (\"count\" in r) {\n                this.total = r.count;\n              } else {\n                this.total = r.dialogs.length;\n              }\n              entities = new Map();\n              messages = new Map();\n              _i = 0, _arr = [].concat(_toConsumableArray(r.users), _toConsumableArray(r.chats));\n            case 12:\n              if (!(_i < _arr.length)) {\n                _context2.next = 20;\n                break;\n              }\n              entity = _arr[_i];\n              if (!(entity instanceof tl_1.Api.UserEmpty || entity instanceof tl_1.Api.ChatEmpty)) {\n                _context2.next = 16;\n                break;\n              }\n              return _context2.abrupt(\"continue\", 17);\n            case 16:\n              entities.set(index_1.utils.getPeerId(entity), entity);\n            case 17:\n              _i++;\n              _context2.next = 12;\n              break;\n            case 20:\n              _iterator = _createForOfIteratorHelper(r.messages);\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  m = _step.value;\n                  message = m;\n                  try {\n                    // todo make sure this never fails\n                    message._finishInit(this.client, entities, undefined);\n                  } catch (e) {\n                    this.client._log.error(\"Got error while trying to finish init message with id \" + m.id);\n                    if (this.client._log.canSend(Logger_1.LogLevel.ERROR)) {\n                      console.error(e);\n                    }\n                  }\n                  messages.set(_dialogMessageKey(message.peerId, message.id), message);\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n              _iterator2 = _createForOfIteratorHelper(r.dialogs);\n              _context2.prev = 23;\n              _iterator2.s();\n            case 25:\n              if ((_step2 = _iterator2.n()).done) {\n                _context2.next = 43;\n                break;\n              }\n              d = _step2.value;\n              if (!(d instanceof tl_1.Api.DialogFolder)) {\n                _context2.next = 29;\n                break;\n              }\n              return _context2.abrupt(\"continue\", 41);\n            case 29:\n              _message = messages.get(_dialogMessageKey(d.peer, d.topMessage));\n              if (!(this.offsetDate != undefined)) {\n                _context2.next = 34;\n                break;\n              }\n              date = _message === null || _message === void 0 ? void 0 : _message.date;\n              if (!(date == undefined || date > this.offsetDate)) {\n                _context2.next = 34;\n                break;\n              }\n              return _context2.abrupt(\"continue\", 41);\n            case 34:\n              peerId = index_1.utils.getPeerId(d.peer);\n              if (this.seen.has(peerId)) {\n                _context2.next = 41;\n                break;\n              }\n              this.seen.add(peerId);\n              if (entities.has(peerId)) {\n                _context2.next = 39;\n                break;\n              }\n              return _context2.abrupt(\"continue\", 41);\n            case 39:\n              cd = new dialog_1.Dialog(this.client, d, entities, _message);\n              if (!this.ignoreMigrated || cd.entity != undefined && \"migratedTo\" in cd.entity) {\n                this.buffer.push(cd);\n              }\n            case 41:\n              _context2.next = 25;\n              break;\n            case 43:\n              _context2.next = 48;\n              break;\n            case 45:\n              _context2.prev = 45;\n              _context2.t0 = _context2[\"catch\"](23);\n              _iterator2.e(_context2.t0);\n            case 48:\n              _context2.prev = 48;\n              _iterator2.f();\n              return _context2.finish(48);\n            case 51:\n              if (!(r.dialogs.length < this.request.limit || !(r instanceof tl_1.Api.messages.DialogsSlice))) {\n                _context2.next = 53;\n                break;\n              }\n              return _context2.abrupt(\"return\", true);\n            case 53:\n              _iterator3 = _createForOfIteratorHelper(r.dialogs.reverse());\n              _context2.prev = 54;\n              _iterator3.s();\n            case 56:\n              if ((_step3 = _iterator3.n()).done) {\n                _context2.next = 63;\n                break;\n              }\n              dialog = _step3.value;\n              lastMessage = messages.get(_dialogMessageKey(dialog.peer, dialog.topMessage));\n              if (!lastMessage) {\n                _context2.next = 61;\n                break;\n              }\n              return _context2.abrupt(\"break\", 63);\n            case 61:\n              _context2.next = 56;\n              break;\n            case 63:\n              _context2.next = 68;\n              break;\n            case 65:\n              _context2.prev = 65;\n              _context2.t1 = _context2[\"catch\"](54);\n              _iterator3.e(_context2.t1);\n            case 68:\n              _context2.prev = 68;\n              _iterator3.f();\n              return _context2.finish(68);\n            case 71:\n              this.request.excludePinned = true;\n              this.request.offsetId = lastMessage ? lastMessage.id : 0;\n              this.request.offsetDate = lastMessage ? lastMessage.date : 0;\n              this.request.offsetPeer = this.buffer[this.buffer.length - 1].inputEntity;\n            case 75:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this, [[23, 45, 48, 51], [54, 65, 68, 71]]);\n      }));\n      function _loadNextChunk() {\n        return _loadNextChunk2.apply(this, arguments);\n      }\n      return _loadNextChunk;\n    }()\n  }]);\n  return _DialogsIter;\n}(requestIter_1.RequestIter, Symbol.asyncIterator);\nexports._DialogsIter = _DialogsIter;\n/** @hidden */\nfunction iterDialogs(client, _ref2) {\n  var _ref2$limit = _ref2.limit,\n    limit = _ref2$limit === void 0 ? undefined : _ref2$limit,\n    _ref2$offsetDate = _ref2.offsetDate,\n    offsetDate = _ref2$offsetDate === void 0 ? undefined : _ref2$offsetDate,\n    _ref2$offsetId = _ref2.offsetId,\n    offsetId = _ref2$offsetId === void 0 ? 0 : _ref2$offsetId,\n    _ref2$offsetPeer = _ref2.offsetPeer,\n    offsetPeer = _ref2$offsetPeer === void 0 ? new tl_1.Api.InputPeerEmpty() : _ref2$offsetPeer,\n    _ref2$ignorePinned = _ref2.ignorePinned,\n    ignorePinned = _ref2$ignorePinned === void 0 ? false : _ref2$ignorePinned,\n    _ref2$ignoreMigrated = _ref2.ignoreMigrated,\n    ignoreMigrated = _ref2$ignoreMigrated === void 0 ? false : _ref2$ignoreMigrated,\n    _ref2$folder = _ref2.folder,\n    folder = _ref2$folder === void 0 ? undefined : _ref2$folder,\n    _ref2$archived = _ref2.archived,\n    archived = _ref2$archived === void 0 ? undefined : _ref2$archived;\n  if (archived != undefined) {\n    folder = archived ? 1 : 0;\n  }\n  return new _DialogsIter(client, limit, {}, {\n    offsetDate: offsetDate,\n    offsetId: offsetId,\n    offsetPeer: offsetPeer,\n    ignorePinned: ignorePinned,\n    ignoreMigrated: ignoreMigrated,\n    folder: folder\n  });\n}\nexports.iterDialogs = iterDialogs;\n/** @hidden */\nfunction getDialogs(_x2, _x3) {\n  return _getDialogs.apply(this, arguments);\n}\nfunction _getDialogs() {\n  _getDialogs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(client, params) {\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          _context3.next = 2;\n          return client.iterDialogs(params).collect();\n        case 2:\n          return _context3.abrupt(\"return\", _context3.sent);\n        case 3:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3);\n  }));\n  return _getDialogs.apply(this, arguments);\n}\nexports.getDialogs = getDialogs;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","getDialogs","iterDialogs","_DialogsIter","tl_1","require","requestIter_1","index_1","dialog_1","big_integer_1","Logger_1","_MAX_CHUNK_SIZE","_dialogMessageKey","peer","messageId","Api","PeerChannel","channelId","undefined","offsetDate","offsetId","offsetPeer","ignorePinned","ignoreMigrated","folder","request","messages","GetDialogs","limit","hash","default","zero","excludePinned","folderId","client","invoke","dialogs","total","count","length","seen","Set","Symbol","asyncIterator","buffer","Math","min","left","r","DialogsNotModified","entities","Map","users","chats","entity","UserEmpty","ChatEmpty","set","utils","getPeerId","m","message","_finishInit","e","_log","error","id","canSend","LogLevel","ERROR","console","peerId","d","DialogFolder","get","topMessage","date","has","add","cd","Dialog","push","DialogsSlice","reverse","dialog","lastMessage","inputEntity","RequestIter","InputPeerEmpty","archived","params","collect"],"sources":["C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/telegram/client/dialogs.js"],"sourcesContent":["\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.getDialogs = exports.iterDialogs = exports._DialogsIter = void 0;\r\nconst tl_1 = require(\"../tl\");\r\nconst requestIter_1 = require(\"../requestIter\");\r\nconst index_1 = require(\"../index\");\r\nconst dialog_1 = require(\"../tl/custom/dialog\");\r\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\r\nconst Logger_1 = require(\"../extensions/Logger\");\r\nconst _MAX_CHUNK_SIZE = 100;\r\n/**\r\n Get the key to get messages from a dialog.\r\n\r\n We cannot just use the message ID because channels share message IDs,\r\n and the peer ID is required to distinguish between them. But it is not\r\n necessary in small group chats and private chats.\r\n * @param {Api.TypePeer} [peer] the dialog peer\r\n * @param {number} [messageId] the message id\r\n * @return {[number,number]} the channel id and message id\r\n */\r\nfunction _dialogMessageKey(peer, messageId) {\r\n    // can't use arrays as keys for map :( need to convert to string.\r\n    return (\"\" +\r\n        [\r\n            peer instanceof tl_1.Api.PeerChannel ? peer.channelId : undefined,\r\n            messageId,\r\n        ]);\r\n}\r\nclass _DialogsIter extends requestIter_1.RequestIter {\r\n    async _init({ offsetDate, offsetId, offsetPeer, ignorePinned, ignoreMigrated, folder, }) {\r\n        this.request = new tl_1.Api.messages.GetDialogs({\r\n            offsetDate,\r\n            offsetId,\r\n            offsetPeer,\r\n            limit: 1,\r\n            hash: big_integer_1.default.zero,\r\n            excludePinned: ignorePinned,\r\n            folderId: folder,\r\n        });\r\n        if (this.limit <= 0) {\r\n            // Special case, get a single dialog and determine count\r\n            const dialogs = await this.client.invoke(this.request);\r\n            if (\"count\" in dialogs) {\r\n                this.total = dialogs.count;\r\n            }\r\n            else {\r\n                this.total = dialogs.dialogs.length;\r\n            }\r\n            return true;\r\n        }\r\n        this.seen = new Set();\r\n        this.offsetDate = offsetDate;\r\n        this.ignoreMigrated = ignoreMigrated;\r\n    }\r\n    [Symbol.asyncIterator]() {\r\n        return super[Symbol.asyncIterator]();\r\n    }\r\n    async _loadNextChunk() {\r\n        if (!this.request || !this.seen || !this.buffer) {\r\n            return;\r\n        }\r\n        this.request.limit = Math.min(this.left, _MAX_CHUNK_SIZE);\r\n        const r = await this.client.invoke(this.request);\r\n        if (r instanceof tl_1.Api.messages.DialogsNotModified) {\r\n            return;\r\n        }\r\n        if (\"count\" in r) {\r\n            this.total = r.count;\r\n        }\r\n        else {\r\n            this.total = r.dialogs.length;\r\n        }\r\n        const entities = new Map();\r\n        const messages = new Map();\r\n        for (const entity of [...r.users, ...r.chats]) {\r\n            if (entity instanceof tl_1.Api.UserEmpty ||\r\n                entity instanceof tl_1.Api.ChatEmpty) {\r\n                continue;\r\n            }\r\n            entities.set(index_1.utils.getPeerId(entity), entity);\r\n        }\r\n        for (const m of r.messages) {\r\n            let message = m;\r\n            try {\r\n                // todo make sure this never fails\r\n                message._finishInit(this.client, entities, undefined);\r\n            }\r\n            catch (e) {\r\n                this.client._log.error(\"Got error while trying to finish init message with id \" +\r\n                    m.id);\r\n                if (this.client._log.canSend(Logger_1.LogLevel.ERROR)) {\r\n                    console.error(e);\r\n                }\r\n            }\r\n            messages.set(_dialogMessageKey(message.peerId, message.id), message);\r\n        }\r\n        for (const d of r.dialogs) {\r\n            if (d instanceof tl_1.Api.DialogFolder) {\r\n                continue;\r\n            }\r\n            const message = messages.get(_dialogMessageKey(d.peer, d.topMessage));\r\n            if (this.offsetDate != undefined) {\r\n                const date = message === null || message === void 0 ? void 0 : message.date;\r\n                if (date == undefined || date > this.offsetDate) {\r\n                    continue;\r\n                }\r\n            }\r\n            const peerId = index_1.utils.getPeerId(d.peer);\r\n            if (!this.seen.has(peerId)) {\r\n                this.seen.add(peerId);\r\n                if (!entities.has(peerId)) {\r\n                    /*\r\n                     > In which case can a UserEmpty appear in the list of banned members?\r\n                     > In a very rare cases. This is possible but isn't an expected behavior.\r\n                     Real world example: https://t.me/TelethonChat/271471\r\n                     */\r\n                    continue;\r\n                }\r\n                const cd = new dialog_1.Dialog(this.client, d, entities, message);\r\n                if (!this.ignoreMigrated ||\r\n                    (cd.entity != undefined && \"migratedTo\" in cd.entity)) {\r\n                    this.buffer.push(cd);\r\n                }\r\n            }\r\n        }\r\n        if (r.dialogs.length < this.request.limit ||\r\n            !(r instanceof tl_1.Api.messages.DialogsSlice)) {\r\n            return true;\r\n        }\r\n        let lastMessage;\r\n        for (let dialog of r.dialogs.reverse()) {\r\n            lastMessage = messages.get(_dialogMessageKey(dialog.peer, dialog.topMessage));\r\n            if (lastMessage) {\r\n                break;\r\n            }\r\n        }\r\n        this.request.excludePinned = true;\r\n        this.request.offsetId = lastMessage ? lastMessage.id : 0;\r\n        this.request.offsetDate = lastMessage ? lastMessage.date : 0;\r\n        this.request.offsetPeer =\r\n            this.buffer[this.buffer.length - 1].inputEntity;\r\n    }\r\n}\r\nexports._DialogsIter = _DialogsIter;\r\n/** @hidden */\r\nfunction iterDialogs(client, { limit = undefined, offsetDate = undefined, offsetId = 0, offsetPeer = new tl_1.Api.InputPeerEmpty(), ignorePinned = false, ignoreMigrated = false, folder = undefined, archived = undefined, }) {\r\n    if (archived != undefined) {\r\n        folder = archived ? 1 : 0;\r\n    }\r\n    return new _DialogsIter(client, limit, {}, {\r\n        offsetDate,\r\n        offsetId,\r\n        offsetPeer,\r\n        ignorePinned,\r\n        ignoreMigrated,\r\n        folder,\r\n    });\r\n}\r\nexports.iterDialogs = iterDialogs;\r\n/** @hidden */\r\nasync function getDialogs(client, params) {\r\n    return (await client.iterDialogs(params).collect());\r\n}\r\nexports.getDialogs = getDialogs;\r\n"],"mappings":"AAAA,YAAY;;AAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACb,IAAIA,eAAe,GAAI,IAAI,IAAI,IAAI,CAACA,eAAe,IAAK,UAAUC,GAAG,EAAE;EACnE,OAAQA,GAAG,IAAIA,GAAG,CAACC,UAAU,GAAID,GAAG,GAAG;IAAE,SAAS,EAAEA;EAAI,CAAC;AAC7D,CAAC;AACDE,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,UAAU,GAAGF,OAAO,CAACG,WAAW,GAAGH,OAAO,CAACI,YAAY,GAAG,KAAK,CAAC;AACxE,IAAMC,IAAI,GAAGC,OAAO,CAAC,OAAO,CAAC;AAC7B,IAAMC,aAAa,GAAGD,OAAO,CAAC,gBAAgB,CAAC;AAC/C,IAAME,OAAO,GAAGF,OAAO,CAAC,UAAU,CAAC;AACnC,IAAMG,QAAQ,GAAGH,OAAO,CAAC,qBAAqB,CAAC;AAC/C,IAAMI,aAAa,GAAGf,eAAe,CAACW,OAAO,CAAC,aAAa,CAAC,CAAC;AAC7D,IAAMK,QAAQ,GAAGL,OAAO,CAAC,sBAAsB,CAAC;AAChD,IAAMM,eAAe,GAAG,GAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,iBAAiB,CAACC,IAAI,EAAEC,SAAS,EAAE;EACxC;EACA,OAAQ,EAAE,GACN,CACID,IAAI,YAAYT,IAAI,CAACW,GAAG,CAACC,WAAW,GAAGH,IAAI,CAACI,SAAS,GAAGC,SAAS,EACjEJ,SAAS,CACZ;AACT;AAAC,IACKX,YAAY;EAAA;EAAA;EAAA;IAAA;IAAA;EAAA;EAAA;IAAA;IAAA;MAAA,wEACd;QAAA;QAAA;UAAA;YAAA;cAAcgB,UAAU,QAAVA,UAAU,EAAEC,QAAQ,QAARA,QAAQ,EAAEC,UAAU,QAAVA,UAAU,EAAEC,YAAY,QAAZA,YAAY,EAAEC,cAAc,QAAdA,cAAc,EAAEC,MAAM,QAANA,MAAM;cAChF,IAAI,CAACC,OAAO,GAAG,IAAIrB,IAAI,CAACW,GAAG,CAACW,QAAQ,CAACC,UAAU,CAAC;gBAC5CR,UAAU,EAAVA,UAAU;gBACVC,QAAQ,EAARA,QAAQ;gBACRC,UAAU,EAAVA,UAAU;gBACVO,KAAK,EAAE,CAAC;gBACRC,IAAI,EAAEpB,aAAa,CAACqB,OAAO,CAACC,IAAI;gBAChCC,aAAa,EAAEV,YAAY;gBAC3BW,QAAQ,EAAET;cACd,CAAC,CAAC;cAAC,MACC,IAAI,CAACI,KAAK,IAAI,CAAC;gBAAA;gBAAA;cAAA;cAAA;cAAA,OAEO,IAAI,CAACM,MAAM,CAACC,MAAM,CAAC,IAAI,CAACV,OAAO,CAAC;YAAA;cAAhDW,OAAO;cACb,IAAI,OAAO,IAAIA,OAAO,EAAE;gBACpB,IAAI,CAACC,KAAK,GAAGD,OAAO,CAACE,KAAK;cAC9B,CAAC,MACI;gBACD,IAAI,CAACD,KAAK,GAAGD,OAAO,CAACA,OAAO,CAACG,MAAM;cACvC;cAAC,iCACM,IAAI;YAAA;cAEf,IAAI,CAACC,IAAI,GAAG,IAAIC,GAAG,EAAE;cACrB,IAAI,CAACtB,UAAU,GAAGA,UAAU;cAC5B,IAAI,CAACI,cAAc,GAAGA,cAAc;YAAC;YAAA;cAAA;UAAA;QAAA;MAAA,CACxC;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;IAAA;IAAA,OACD,iBAAyB;MACrB,qDAAamB,MAAM,CAACC,aAAa;IACrC;EAAC;IAAA;IAAA;MAAA,iFACD;QAAA;QAAA;UAAA;YAAA;cAAA,MACQ,CAAC,IAAI,CAAClB,OAAO,IAAI,CAAC,IAAI,CAACe,IAAI,IAAI,CAAC,IAAI,CAACI,MAAM;gBAAA;gBAAA;cAAA;cAAA;YAAA;cAG/C,IAAI,CAACnB,OAAO,CAACG,KAAK,GAAGiB,IAAI,CAACC,GAAG,CAAC,IAAI,CAACC,IAAI,EAAEpC,eAAe,CAAC;cAAC;cAAA,OAC1C,IAAI,CAACuB,MAAM,CAACC,MAAM,CAAC,IAAI,CAACV,OAAO,CAAC;YAAA;cAA1CuB,CAAC;cAAA,MACHA,CAAC,YAAY5C,IAAI,CAACW,GAAG,CAACW,QAAQ,CAACuB,kBAAkB;gBAAA;gBAAA;cAAA;cAAA;YAAA;cAGrD,IAAI,OAAO,IAAID,CAAC,EAAE;gBACd,IAAI,CAACX,KAAK,GAAGW,CAAC,CAACV,KAAK;cACxB,CAAC,MACI;gBACD,IAAI,CAACD,KAAK,GAAGW,CAAC,CAACZ,OAAO,CAACG,MAAM;cACjC;cACMW,QAAQ,GAAG,IAAIC,GAAG,EAAE;cACpBzB,QAAQ,GAAG,IAAIyB,GAAG,EAAE;cAAA,4CACDH,CAAC,CAACI,KAAK,sBAAKJ,CAAC,CAACK,KAAK;YAAA;cAAA;gBAAA;gBAAA;cAAA;cAAjCC,MAAM;cAAA,MACTA,MAAM,YAAYlD,IAAI,CAACW,GAAG,CAACwC,SAAS,IACpCD,MAAM,YAAYlD,IAAI,CAACW,GAAG,CAACyC,SAAS;gBAAA;gBAAA;cAAA;cAAA;YAAA;cAGxCN,QAAQ,CAACO,GAAG,CAAClD,OAAO,CAACmD,KAAK,CAACC,SAAS,CAACL,MAAM,CAAC,EAAEA,MAAM,CAAC;YAAC;cAAA;cAAA;cAAA;YAAA;cAAA,uCAE1CN,CAAC,CAACtB,QAAQ;cAAA;gBAA1B,oDAA4B;kBAAjBkC,CAAC;kBACJC,OAAO,GAAGD,CAAC;kBACf,IAAI;oBACA;oBACAC,OAAO,CAACC,WAAW,CAAC,IAAI,CAAC5B,MAAM,EAAEgB,QAAQ,EAAEhC,SAAS,CAAC;kBACzD,CAAC,CACD,OAAO6C,CAAC,EAAE;oBACN,IAAI,CAAC7B,MAAM,CAAC8B,IAAI,CAACC,KAAK,CAAC,wDAAwD,GAC3EL,CAAC,CAACM,EAAE,CAAC;oBACT,IAAI,IAAI,CAAChC,MAAM,CAAC8B,IAAI,CAACG,OAAO,CAACzD,QAAQ,CAAC0D,QAAQ,CAACC,KAAK,CAAC,EAAE;sBACnDC,OAAO,CAACL,KAAK,CAACF,CAAC,CAAC;oBACpB;kBACJ;kBACArC,QAAQ,CAAC+B,GAAG,CAAC7C,iBAAiB,CAACiD,OAAO,CAACU,MAAM,EAAEV,OAAO,CAACK,EAAE,CAAC,EAAEL,OAAO,CAAC;gBACxE;cAAC;gBAAA;cAAA;gBAAA;cAAA;cAAA,wCACeb,CAAC,CAACZ,OAAO;cAAA;cAAA;YAAA;cAAA;gBAAA;gBAAA;cAAA;cAAdoC,CAAC;cAAA,MACJA,CAAC,YAAYpE,IAAI,CAACW,GAAG,CAAC0D,YAAY;gBAAA;gBAAA;cAAA;cAAA;YAAA;cAGhCZ,QAAO,GAAGnC,QAAQ,CAACgD,GAAG,CAAC9D,iBAAiB,CAAC4D,CAAC,CAAC3D,IAAI,EAAE2D,CAAC,CAACG,UAAU,CAAC,CAAC;cAAA,MACjE,IAAI,CAACxD,UAAU,IAAID,SAAS;gBAAA;gBAAA;cAAA;cACtB0D,IAAI,GAAGf,QAAO,KAAK,IAAI,IAAIA,QAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,QAAO,CAACe,IAAI;cAAA,MACvEA,IAAI,IAAI1D,SAAS,IAAI0D,IAAI,GAAG,IAAI,CAACzD,UAAU;gBAAA;gBAAA;cAAA;cAAA;YAAA;cAI7CoD,MAAM,GAAGhE,OAAO,CAACmD,KAAK,CAACC,SAAS,CAACa,CAAC,CAAC3D,IAAI,CAAC;cAAA,IACzC,IAAI,CAAC2B,IAAI,CAACqC,GAAG,CAACN,MAAM,CAAC;gBAAA;gBAAA;cAAA;cACtB,IAAI,CAAC/B,IAAI,CAACsC,GAAG,CAACP,MAAM,CAAC;cAAC,IACjBrB,QAAQ,CAAC2B,GAAG,CAACN,MAAM,CAAC;gBAAA;gBAAA;cAAA;cAAA;YAAA;cAQnBQ,EAAE,GAAG,IAAIvE,QAAQ,CAACwE,MAAM,CAAC,IAAI,CAAC9C,MAAM,EAAEsC,CAAC,EAAEtB,QAAQ,EAAEW,QAAO,CAAC;cACjE,IAAI,CAAC,IAAI,CAACtC,cAAc,IACnBwD,EAAE,CAACzB,MAAM,IAAIpC,SAAS,IAAI,YAAY,IAAI6D,EAAE,CAACzB,MAAO,EAAE;gBACvD,IAAI,CAACV,MAAM,CAACqC,IAAI,CAACF,EAAE,CAAC;cACxB;YAAC;cAAA;cAAA;YAAA;cAAA;cAAA;YAAA;cAAA;cAAA;cAAA;YAAA;cAAA;cAAA;cAAA;YAAA;cAAA,MAGL/B,CAAC,CAACZ,OAAO,CAACG,MAAM,GAAG,IAAI,CAACd,OAAO,CAACG,KAAK,IACrC,EAAEoB,CAAC,YAAY5C,IAAI,CAACW,GAAG,CAACW,QAAQ,CAACwD,YAAY,CAAC;gBAAA;gBAAA;cAAA;cAAA,kCACvC,IAAI;YAAA;cAAA,wCAGIlC,CAAC,CAACZ,OAAO,CAAC+C,OAAO,EAAE;cAAA;cAAA;YAAA;cAAA;gBAAA;gBAAA;cAAA;cAA7BC,MAAM;cACXC,WAAW,GAAG3D,QAAQ,CAACgD,GAAG,CAAC9D,iBAAiB,CAACwE,MAAM,CAACvE,IAAI,EAAEuE,MAAM,CAACT,UAAU,CAAC,CAAC;cAAC,KAC1EU,WAAW;gBAAA;gBAAA;cAAA;cAAA;YAAA;cAAA;cAAA;YAAA;cAAA;cAAA;YAAA;cAAA;cAAA;cAAA;YAAA;cAAA;cAAA;cAAA;YAAA;cAInB,IAAI,CAAC5D,OAAO,CAACO,aAAa,GAAG,IAAI;cACjC,IAAI,CAACP,OAAO,CAACL,QAAQ,GAAGiE,WAAW,GAAGA,WAAW,CAACnB,EAAE,GAAG,CAAC;cACxD,IAAI,CAACzC,OAAO,CAACN,UAAU,GAAGkE,WAAW,GAAGA,WAAW,CAACT,IAAI,GAAG,CAAC;cAC5D,IAAI,CAACnD,OAAO,CAACJ,UAAU,GACnB,IAAI,CAACuB,MAAM,CAAC,IAAI,CAACA,MAAM,CAACL,MAAM,GAAG,CAAC,CAAC,CAAC+C,WAAW;YAAC;YAAA;cAAA;UAAA;QAAA;MAAA,CACvD;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;EAAA;AAAA,EAjHsBhF,aAAa,CAACiF,WAAW,EA0B/C7C,MAAM,CAACC,aAAa;AAyFzB5C,OAAO,CAACI,YAAY,GAAGA,YAAY;AACnC;AACA,SAASD,WAAW,CAACgC,MAAM,SAAoM;EAAA,wBAAhMN,KAAK;IAALA,KAAK,4BAAGV,SAAS;IAAA,yBAAEC,UAAU;IAAVA,UAAU,iCAAGD,SAAS;IAAA,uBAAEE,QAAQ;IAARA,QAAQ,+BAAG,CAAC;IAAA,yBAAEC,UAAU;IAAVA,UAAU,iCAAG,IAAIjB,IAAI,CAACW,GAAG,CAACyE,cAAc,EAAE;IAAA,2BAAElE,YAAY;IAAZA,YAAY,mCAAG,KAAK;IAAA,6BAAEC,cAAc;IAAdA,cAAc,qCAAG,KAAK;IAAA,qBAAEC,MAAM;IAANA,MAAM,6BAAGN,SAAS;IAAA,uBAAEuE,QAAQ;IAARA,QAAQ,+BAAGvE,SAAS;EACtN,IAAIuE,QAAQ,IAAIvE,SAAS,EAAE;IACvBM,MAAM,GAAGiE,QAAQ,GAAG,CAAC,GAAG,CAAC;EAC7B;EACA,OAAO,IAAItF,YAAY,CAAC+B,MAAM,EAAEN,KAAK,EAAE,CAAC,CAAC,EAAE;IACvCT,UAAU,EAAVA,UAAU;IACVC,QAAQ,EAARA,QAAQ;IACRC,UAAU,EAAVA,UAAU;IACVC,YAAY,EAAZA,YAAY;IACZC,cAAc,EAAdA,cAAc;IACdC,MAAM,EAANA;EACJ,CAAC,CAAC;AACN;AACAzB,OAAO,CAACG,WAAW,GAAGA,WAAW;AACjC;AAAA,SACeD,UAAU;EAAA;AAAA;AAAA;EAAA,yEAAzB,kBAA0BiC,MAAM,EAAEwD,MAAM;IAAA;MAAA;QAAA;UAAA;UAAA,OACtBxD,MAAM,CAAChC,WAAW,CAACwF,MAAM,CAAC,CAACC,OAAO,EAAE;QAAA;UAAA;QAAA;QAAA;UAAA;MAAA;IAAA;EAAA,CACrD;EAAA;AAAA;AACD5F,OAAO,CAACE,UAAU,GAAGA,UAAU"},"metadata":{},"sourceType":"script","externalDependencies":[]}