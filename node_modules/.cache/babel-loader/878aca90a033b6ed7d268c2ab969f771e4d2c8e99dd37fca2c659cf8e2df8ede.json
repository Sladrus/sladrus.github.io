{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _createForOfIteratorHelper = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _slicedToArray = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createClass = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _classCallCheck = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _assertThisInitialized = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/assertThisInitialized.js\").default;\nvar _inherits = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _wrapNativeSuper = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/wrapNativeSuper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar buffer_1 = require(\"buffer/\");\nvar _require = require(\"../inspect\"),\n  inspect = _require.inspect;\nvar bigInt = require(\"big-integer\");\nvar _require2 = require(\"../Helpers\"),\n  generateRandomBytes = _require2.generateRandomBytes,\n  readBigIntFromBuffer = _require2.readBigIntFromBuffer,\n  isArrayLike = _require2.isArrayLike,\n  betterConsoleLog = _require2.betterConsoleLog;\nvar tlContent = require(\"./apiTl.js\");\nvar schemeContent = require(\"./schemaTl.js\");\nfunction generateRandomBigInt() {\n  return readBigIntFromBuffer(generateRandomBytes(8), false, true);\n}\nvar _require3 = require(\"./generationHelpers\"),\n  parseTl = _require3.parseTl,\n  serializeBytes = _require3.serializeBytes,\n  serializeDate = _require3.serializeDate;\nvar _require4 = require(\"../Helpers\"),\n  toSignedLittleBuffer = _require4.toSignedLittleBuffer;\nvar NAMED_AUTO_CASTS = new Set([\"chatId,int\"]);\nvar NAMED_BLACKLIST = new Set([\"discardEncryption\"]);\nvar AUTO_CASTS = new Set([\"InputPeer\", \"InputChannel\", \"InputUser\", \"InputDialogPeer\", \"InputNotifyPeer\", \"InputMedia\", \"InputPhoto\", \"InputMessage\", \"InputDocument\", \"InputChatPhoto\"]);\nvar CastError = /*#__PURE__*/function (_Error) {\n  _inherits(CastError, _Error);\n  var _super = _createSuper(CastError);\n  function CastError(objectName, expected, actual) {\n    var _this;\n    _classCallCheck(this, CastError);\n    // Pass remaining arguments (including vendor specific ones) to parent constructor\n    var message = \"Found wrong type for \" + objectName + \". expected \" + expected + \" but received \" + actual + \".If you think this is a mistake please report it.\";\n    for (var _len = arguments.length, params = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n      params[_key - 3] = arguments[_key];\n    }\n    _this = _super.call.apply(_super, [this, message].concat(params));\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(_assertThisInitialized(_this), CastError);\n    }\n    _this.name = \"CastError\";\n    // Custom debugging information\n    return _this;\n  }\n  return _createClass(CastError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nvar CACHING_SUPPORTED = typeof self !== \"undefined\" && self.localStorage !== undefined;\nvar CACHE_KEY = \"GramJs:apiCache\";\nfunction buildApiFromTlSchema() {\n  var definitions;\n  var fromCache = CACHING_SUPPORTED && loadFromCache();\n  if (fromCache) {\n    definitions = fromCache;\n  } else {\n    definitions = loadFromTlSchemas();\n    if (CACHING_SUPPORTED) {\n      localStorage.setItem(CACHE_KEY, JSON.stringify(definitions));\n    }\n  }\n  return createClasses(\"all\", definitions);\n}\nfunction loadFromCache() {\n  var jsonCache = localStorage.getItem(CACHE_KEY);\n  return jsonCache && JSON.parse(jsonCache);\n}\nfunction loadFromTlSchemas() {\n  var _extractParams = extractParams(tlContent),\n    _extractParams2 = _slicedToArray(_extractParams, 2),\n    constructorParamsApi = _extractParams2[0],\n    functionParamsApi = _extractParams2[1];\n  var _extractParams3 = extractParams(schemeContent),\n    _extractParams4 = _slicedToArray(_extractParams3, 2),\n    constructorParamsSchema = _extractParams4[0],\n    functionParamsSchema = _extractParams4[1];\n  var constructors = [].concat(constructorParamsApi, constructorParamsSchema);\n  var requests = [].concat(functionParamsApi, functionParamsSchema);\n  return [].concat(constructors, requests);\n}\nfunction extractParams(fileContent) {\n  var f = parseTl(fileContent, 109);\n  var constructors = [];\n  var functions = [];\n  var _iterator = _createForOfIteratorHelper(f),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var d = _step.value;\n      d.isFunction ? functions.push(d) : constructors.push(d);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return [constructors, functions];\n}\nfunction argToBytes(x, type, argName, requestName) {\n  switch (type) {\n    case \"int\":\n      var i = buffer_1.Buffer.alloc(4);\n      i.writeInt32LE(x, 0);\n      return i;\n    case \"long\":\n      return toSignedLittleBuffer(x, 8);\n    case \"int128\":\n      return toSignedLittleBuffer(x, 16);\n    case \"int256\":\n      return toSignedLittleBuffer(x, 32);\n    case \"double\":\n      var d = buffer_1.Buffer.alloc(8);\n      d.writeDoubleLE(x, 0);\n      return d;\n    case \"string\":\n      return serializeBytes(x);\n    case \"Bool\":\n      return x ? buffer_1.Buffer.from(\"b5757299\", \"hex\") : buffer_1.Buffer.from(\"379779bc\", \"hex\");\n    case \"true\":\n      return buffer_1.Buffer.alloc(0);\n    case \"bytes\":\n      return serializeBytes(x);\n    case \"date\":\n      return serializeDate(x);\n    default:\n      if (x === undefined || typeof x.getBytes !== \"function\") {\n        throw new Error(\"Required object \".concat(argName, \" of \").concat(requestName, \" is undefined\"));\n      }\n      return x.getBytes();\n  }\n}\nfunction getInputFromResolve(_x, _x2, _x3, _x4) {\n  return _getInputFromResolve.apply(this, arguments);\n}\nfunction _getInputFromResolve() {\n  _getInputFromResolve = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(utils, client, peer, peerType) {\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.t0 = peerType;\n          _context2.next = _context2.t0 === \"InputPeer\" ? 3 : _context2.t0 === \"InputChannel\" ? 8 : _context2.t0 === \"InputUser\" ? 13 : _context2.t0 === \"InputDialogPeer\" ? 18 : _context2.t0 === \"InputNotifyPeer\" ? 21 : _context2.t0 === \"InputMedia\" ? 24 : _context2.t0 === \"InputPhoto\" ? 25 : _context2.t0 === \"InputMessage\" ? 26 : _context2.t0 === \"InputDocument\" ? 27 : _context2.t0 === \"InputChatPhoto\" ? 28 : _context2.t0 === \"chatId,int\" ? 29 : 32;\n          break;\n        case 3:\n          _context2.t1 = utils;\n          _context2.next = 6;\n          return client.getInputEntity(peer);\n        case 6:\n          _context2.t2 = _context2.sent;\n          return _context2.abrupt(\"return\", _context2.t1.getInputPeer.call(_context2.t1, _context2.t2));\n        case 8:\n          _context2.t3 = utils;\n          _context2.next = 11;\n          return client.getInputEntity(peer);\n        case 11:\n          _context2.t4 = _context2.sent;\n          return _context2.abrupt(\"return\", _context2.t3.getInputChannel.call(_context2.t3, _context2.t4));\n        case 13:\n          _context2.t5 = utils;\n          _context2.next = 16;\n          return client.getInputEntity(peer);\n        case 16:\n          _context2.t6 = _context2.sent;\n          return _context2.abrupt(\"return\", _context2.t5.getInputUser.call(_context2.t5, _context2.t6));\n        case 18:\n          _context2.next = 20;\n          return client._getInputDialog(peer);\n        case 20:\n          return _context2.abrupt(\"return\", _context2.sent);\n        case 21:\n          _context2.next = 23;\n          return client._getInputNotify(peer);\n        case 23:\n          return _context2.abrupt(\"return\", _context2.sent);\n        case 24:\n          return _context2.abrupt(\"return\", utils.getInputMedia(peer));\n        case 25:\n          return _context2.abrupt(\"return\", utils.getInputPhoto(peer));\n        case 26:\n          return _context2.abrupt(\"return\", utils.getInputMessage(peer));\n        case 27:\n          return _context2.abrupt(\"return\", utils.getInputDocument(peer));\n        case 28:\n          return _context2.abrupt(\"return\", utils.getInputChatPhoto(peer));\n        case 29:\n          _context2.next = 31;\n          return client.getPeerId(peer, false);\n        case 31:\n          return _context2.abrupt(\"return\", _context2.sent);\n        case 32:\n          throw new Error(\"unsupported peer type : \" + peerType);\n        case 33:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return _getInputFromResolve.apply(this, arguments);\n}\nfunction getArgFromReader(reader, arg) {\n  if (arg.isVector) {\n    if (arg.useVectorId) {\n      reader.readInt();\n    }\n    var temp = [];\n    var len = reader.readInt();\n    arg.isVector = false;\n    for (var i = 0; i < len; i++) {\n      temp.push(getArgFromReader(reader, arg));\n    }\n    arg.isVector = true;\n    return temp;\n  } else if (arg.flagIndicator) {\n    return reader.readInt();\n  } else {\n    switch (arg.type) {\n      case \"int\":\n        return reader.readInt();\n      case \"long\":\n        return reader.readLong();\n      case \"int128\":\n        return reader.readLargeInt(128);\n      case \"int256\":\n        return reader.readLargeInt(256);\n      case \"double\":\n        return reader.readDouble();\n      case \"string\":\n        return reader.tgReadString();\n      case \"Bool\":\n        return reader.tgReadBool();\n      case \"true\":\n        return true;\n      case \"bytes\":\n        return reader.tgReadBytes();\n      case \"date\":\n        return reader.tgReadDate();\n      default:\n        if (!arg.skipConstructorId) {\n          return reader.tgReadObject();\n        } else {\n          return api.constructors[arg.type].fromReader(reader);\n        }\n    }\n  }\n}\nfunction compareType(value, type) {\n  var correct = true;\n  switch (type) {\n    case \"number\":\n      correct = typeof value === \"number\" || value === undefined;\n      break;\n    case \"string\":\n    case \"boolean\":\n      correct = typeof value === type;\n      break;\n    case \"bigInt\":\n      correct = bigInt.isInstance(value) || typeof value === \"bigint\" || typeof value === \"number\" || typeof value === \"string\" || value === undefined;\n      break;\n    case \"true\":\n      // true value is always correct\n      break;\n    case \"buffer\":\n      correct = buffer_1.Buffer.isBuffer(value);\n      break;\n    case \"date\":\n      correct = value && Object.prototype.toString.call(value) === \"[object Date]\" && !isNaN(value) || typeof value === \"number\";\n      break;\n    default:\n      console.error(new Error(\"Unknown type.\" + type));\n  }\n  return correct;\n}\nfunction createClasses(classesType, params) {\n  var classes = {};\n  var _iterator2 = _createForOfIteratorHelper(params),\n    _step2;\n  try {\n    var _loop = function _loop() {\n      var classParams = _step2.value;\n      var name = classParams.name,\n        constructorId = classParams.constructorId,\n        subclassOfId = classParams.subclassOfId,\n        argsConfig = classParams.argsConfig,\n        namespace = classParams.namespace,\n        isFunction = classParams.isFunction,\n        result = classParams.result;\n      var fullName = [namespace, name].join(\".\").replace(/^\\./, \"\");\n      var VirtualClass = /*#__PURE__*/function (_inspect$custom) {\n        function VirtualClass(args) {\n          _classCallCheck(this, VirtualClass);\n          this.CONSTRUCTOR_ID = constructorId;\n          this.SUBCLASS_OF_ID = subclassOfId;\n          this.className = fullName;\n          this.classType = isFunction ? \"request\" : \"constructor\";\n          args = args || {};\n          this.originalArgs = args;\n          this.init(args);\n          for (var argName in argsConfig) {\n            if (argName === \"randomId\" && !args[argName]) {\n              if (argsConfig[argName].isVector) {\n                var rands = [];\n                for (var i = 0; i < args[\"id\"].length; i++) {\n                  rands.push(generateRandomBigInt());\n                }\n                this[argName] = rands;\n              } else {\n                this[argName] = generateRandomBigInt();\n              }\n            } else {\n              this[argName] = args[argName];\n            }\n          }\n        }\n        _createClass(VirtualClass, [{\n          key: \"init\",\n          value: function init(args) {}\n        }, {\n          key: \"validate\",\n          value: function validate() {\n            for (var arg in argsConfig) {\n              if (argsConfig.hasOwnProperty(arg)) {\n                if (argsConfig[arg].flagIndicator || argsConfig[arg].isFlag) {\n                  // we don't care about flags\n                  continue;\n                }\n                var currentValue = this[arg];\n                this.assertType(arg, argsConfig[arg], currentValue);\n              }\n            }\n          }\n        }, {\n          key: \"assertType\",\n          value: function assertType(objectName, object, value) {\n            var expected;\n            if (object[\"isVector\"]) {\n              if (!isArrayLike(value)) {\n                console.error(new CastError(objectName, \"array\", value));\n              }\n              if (value == undefined) {\n                value = [];\n              }\n              var _iterator3 = _createForOfIteratorHelper(value),\n                _step3;\n              try {\n                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                  var o = _step3.value;\n                  this.assertType(objectName, Object.assign(Object.assign({}, object), {\n                    isVector: false\n                  }), o);\n                }\n              } catch (err) {\n                _iterator3.e(err);\n              } finally {\n                _iterator3.f();\n              }\n            } else {\n              switch (object[\"type\"]) {\n                case \"int\":\n                  expected = \"number\";\n                  break;\n                case \"long\":\n                case \"int128\":\n                case \"int256\":\n                  expected = \"bigInt\";\n                  break;\n                case \"double\":\n                  expected = \"number\";\n                  break;\n                case \"string\":\n                  expected = \"string\";\n                  break;\n                case \"Bool\":\n                  expected = \"boolean\";\n                  break;\n                case \"true\":\n                  expected = \"true\";\n                  break;\n                case \"bytes\":\n                  expected = \"buffer\";\n                  break;\n                case \"date\":\n                  expected = \"date\";\n                  break;\n                default:\n                  expected = \"object\";\n              }\n              if (expected === \"object\") {\n                // will be validated in get byte();\n              } else {\n                var isCorrectType = compareType(value, expected);\n                if (isCorrectType !== true) {\n                  console.error(new CastError(objectName, expected, value));\n                }\n              }\n            }\n          }\n        }, {\n          key: \"getBytes\",\n          value: function getBytes() {\n            var _this2 = this;\n            try {\n              this.validate();\n            } catch (e) {\n              // feature still in alpha so errors are expected.\n            }\n            var idForBytes = this.CONSTRUCTOR_ID;\n            var c = buffer_1.Buffer.alloc(4);\n            c.writeUInt32LE(idForBytes, 0);\n            var buffers = [c];\n            var _loop2 = function _loop2(arg) {\n              if (argsConfig.hasOwnProperty(arg)) {\n                if (argsConfig[arg].isFlag) {\n                  if (_this2[arg] === false && argsConfig[arg].type !== \"Bool\" || _this2[arg] === null || _this2[arg] === undefined || argsConfig[arg].type === \"true\") {\n                    return \"continue\";\n                  }\n                }\n                if (argsConfig[arg].isVector) {\n                  if (argsConfig[arg].useVectorId) {\n                    buffers.push(buffer_1.Buffer.from(\"15c4b51c\", \"hex\"));\n                  }\n                  var l = buffer_1.Buffer.alloc(4);\n                  l.writeInt32LE(_this2[arg].length, 0);\n                  buffers.push(l, buffer_1.Buffer.concat(_this2[arg].map(function (x) {\n                    return argToBytes(x, argsConfig[arg].type, fullName);\n                  })));\n                } else if (argsConfig[arg].flagIndicator) {\n                  if (!Object.values(argsConfig).some(function (f) {\n                    return f.isFlag;\n                  })) {\n                    buffers.push(buffer_1.Buffer.alloc(4));\n                  } else {\n                    var flagCalculate = 0;\n                    for (var _f in argsConfig) {\n                      if (argsConfig[_f].isFlag && arg === argsConfig[_f].flagName) {\n                        if (_this2[_f] === false && argsConfig[_f].type !== \"Bool\" || _this2[_f] === undefined || _this2[_f] === null) {\n                          flagCalculate |= 0;\n                        } else {\n                          flagCalculate |= 1 << argsConfig[_f].flagIndex;\n                        }\n                      }\n                    }\n                    var f = buffer_1.Buffer.alloc(4);\n                    f.writeUInt32LE(flagCalculate, 0);\n                    buffers.push(f);\n                  }\n                } else {\n                  buffers.push(argToBytes(_this2[arg], argsConfig[arg].type, arg, fullName));\n                  if (_this2[arg] && typeof _this2[arg].getBytes === \"function\") {\n                    var boxed = argsConfig[arg].type.charAt(argsConfig[arg].type.indexOf(\".\") + 1);\n                    boxed = boxed === boxed.toUpperCase();\n                    if (!boxed) {\n                      buffers.shift();\n                    }\n                  }\n                }\n              }\n            };\n            for (var arg in argsConfig) {\n              var _ret = _loop2(arg);\n              if (_ret === \"continue\") continue;\n            }\n            return buffer_1.Buffer.concat(buffers);\n          }\n        }, {\n          key: \"readResult\",\n          value: function readResult(reader) {\n            if (!isFunction) {\n              throw new Error(\"`readResult()` called for non-request instance\");\n            }\n            var m = result.match(/Vector<(int|long)>/);\n            if (m) {\n              reader.readInt();\n              var temp = [];\n              var len = reader.readInt();\n              if (m[1] === \"int\") {\n                for (var i = 0; i < len; i++) {\n                  temp.push(reader.readInt());\n                }\n              } else {\n                for (var _i = 0; _i < len; _i++) {\n                  temp.push(reader.readLong());\n                }\n              }\n              return temp;\n            } else {\n              return reader.tgReadObject();\n            }\n          }\n        }, {\n          key: \"resolve\",\n          value: function () {\n            var _resolve = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(client, utils) {\n              var arg, temp, _iterator4, _step4, x;\n              return _regeneratorRuntime().wrap(function _callee$(_context) {\n                while (1) switch (_context.prev = _context.next) {\n                  case 0:\n                    if (isFunction) {\n                      _context.next = 2;\n                      break;\n                    }\n                    throw new Error(\"`resolve()` called for non-request instance\");\n                  case 2:\n                    _context.t0 = _regeneratorRuntime().keys(argsConfig);\n                  case 3:\n                    if ((_context.t1 = _context.t0()).done) {\n                      _context.next = 42;\n                      break;\n                    }\n                    arg = _context.t1.value;\n                    if (!argsConfig.hasOwnProperty(arg)) {\n                      _context.next = 40;\n                      break;\n                    }\n                    if (AUTO_CASTS.has(argsConfig[arg].type)) {\n                      _context.next = 9;\n                      break;\n                    }\n                    if (NAMED_AUTO_CASTS.has(\"\".concat(argsConfig[arg].name, \",\").concat(argsConfig[arg].type))) {\n                      _context.next = 9;\n                      break;\n                    }\n                    return _context.abrupt(\"continue\", 3);\n                  case 9:\n                    if (!argsConfig[arg].isFlag) {\n                      _context.next = 12;\n                      break;\n                    }\n                    if (this[arg]) {\n                      _context.next = 12;\n                      break;\n                    }\n                    return _context.abrupt(\"continue\", 3);\n                  case 12:\n                    if (!argsConfig[arg].isVector) {\n                      _context.next = 37;\n                      break;\n                    }\n                    temp = [];\n                    _iterator4 = _createForOfIteratorHelper(this[arg]);\n                    _context.prev = 15;\n                    _iterator4.s();\n                  case 17:\n                    if ((_step4 = _iterator4.n()).done) {\n                      _context.next = 26;\n                      break;\n                    }\n                    x = _step4.value;\n                    _context.t2 = temp;\n                    _context.next = 22;\n                    return getInputFromResolve(utils, client, x, argsConfig[arg].type);\n                  case 22:\n                    _context.t3 = _context.sent;\n                    _context.t2.push.call(_context.t2, _context.t3);\n                  case 24:\n                    _context.next = 17;\n                    break;\n                  case 26:\n                    _context.next = 31;\n                    break;\n                  case 28:\n                    _context.prev = 28;\n                    _context.t4 = _context[\"catch\"](15);\n                    _iterator4.e(_context.t4);\n                  case 31:\n                    _context.prev = 31;\n                    _iterator4.f();\n                    return _context.finish(31);\n                  case 34:\n                    this[arg] = temp;\n                    _context.next = 40;\n                    break;\n                  case 37:\n                    _context.next = 39;\n                    return getInputFromResolve(utils, client, this[arg], argsConfig[arg].type);\n                  case 39:\n                    this[arg] = _context.sent;\n                  case 40:\n                    _context.next = 3;\n                    break;\n                  case 42:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }, _callee, this, [[15, 28, 31, 34]]);\n            }));\n            function resolve(_x5, _x6) {\n              return _resolve.apply(this, arguments);\n            }\n            return resolve;\n          }()\n        }, {\n          key: _inspect$custom,\n          value: function value() {\n            return betterConsoleLog(this);\n          }\n        }, {\n          key: \"toJSON\",\n          value: function toJSON() {\n            return Object.assign(Object.assign({}, this.originalArgs), {\n              className: fullName\n            });\n          }\n        }], [{\n          key: \"fromReader\",\n          value: function fromReader(reader) {\n            var args = {};\n            for (var argName in argsConfig) {\n              if (argsConfig.hasOwnProperty(argName)) {\n                var arg = argsConfig[argName];\n                if (arg.isFlag) {\n                  if (arg.type === \"true\") {\n                    args[argName] = Boolean(args[arg.flagName] & 1 << arg.flagIndex);\n                    continue;\n                  }\n                  if (args[arg.flagName] & 1 << arg.flagIndex) {\n                    args[argName] = getArgFromReader(reader, arg);\n                  } else {\n                    args[argName] = null;\n                  }\n                } else {\n                  if (arg.flagIndicator) {\n                    arg.name = argName;\n                  }\n                  args[argName] = getArgFromReader(reader, arg);\n                }\n              }\n            }\n            return new this(args);\n          }\n        }]);\n        return VirtualClass;\n      }(inspect.custom);\n      VirtualClass.CONSTRUCTOR_ID = constructorId;\n      VirtualClass.SUBCLASS_OF_ID = subclassOfId;\n      VirtualClass.className = fullName;\n      VirtualClass.classType = isFunction ? \"request\" : \"constructor\";\n      if (namespace) {\n        if (!classes[namespace]) {\n          classes[namespace] = {};\n        }\n        classes[namespace][name] = VirtualClass;\n      } else {\n        classes[name] = VirtualClass;\n      }\n    };\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      _loop();\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return classes;\n}\nvar api = buildApiFromTlSchema();\nmodule.exports = {\n  Api: api\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","buffer_1","require","inspect","bigInt","generateRandomBytes","readBigIntFromBuffer","isArrayLike","betterConsoleLog","tlContent","schemeContent","generateRandomBigInt","parseTl","serializeBytes","serializeDate","toSignedLittleBuffer","NAMED_AUTO_CASTS","Set","NAMED_BLACKLIST","AUTO_CASTS","CastError","objectName","expected","actual","message","params","Error","captureStackTrace","name","CACHING_SUPPORTED","self","localStorage","undefined","CACHE_KEY","buildApiFromTlSchema","definitions","fromCache","loadFromCache","loadFromTlSchemas","setItem","JSON","stringify","createClasses","jsonCache","getItem","parse","extractParams","constructorParamsApi","functionParamsApi","constructorParamsSchema","functionParamsSchema","constructors","concat","requests","fileContent","f","functions","d","isFunction","push","argToBytes","x","type","argName","requestName","i","Buffer","alloc","writeInt32LE","writeDoubleLE","from","getBytes","getInputFromResolve","utils","client","peer","peerType","getInputEntity","getInputPeer","getInputChannel","getInputUser","_getInputDialog","_getInputNotify","getInputMedia","getInputPhoto","getInputMessage","getInputDocument","getInputChatPhoto","getPeerId","getArgFromReader","reader","arg","isVector","useVectorId","readInt","temp","len","flagIndicator","readLong","readLargeInt","readDouble","tgReadString","tgReadBool","tgReadBytes","tgReadDate","skipConstructorId","tgReadObject","api","fromReader","compareType","correct","isInstance","isBuffer","prototype","toString","call","isNaN","console","error","classesType","classes","classParams","constructorId","subclassOfId","argsConfig","namespace","result","fullName","join","replace","VirtualClass","args","CONSTRUCTOR_ID","SUBCLASS_OF_ID","className","classType","originalArgs","init","rands","length","hasOwnProperty","isFlag","currentValue","assertType","object","o","assign","isCorrectType","validate","e","idForBytes","c","writeUInt32LE","buffers","l","map","values","some","flagCalculate","flagName","flagIndex","boxed","charAt","indexOf","toUpperCase","shift","m","match","has","Boolean","custom","module","Api"],"sources":["C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/telegram/tl/api.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst buffer_1 = require(\"buffer/\");\r\nconst { inspect } = require(\"../inspect\");\r\nconst bigInt = require(\"big-integer\");\r\nconst { generateRandomBytes, readBigIntFromBuffer, isArrayLike, betterConsoleLog, } = require(\"../Helpers\");\r\nconst tlContent = require(\"./apiTl.js\");\r\nconst schemeContent = require(\"./schemaTl.js\");\r\nfunction generateRandomBigInt() {\r\n    return readBigIntFromBuffer(generateRandomBytes(8), false, true);\r\n}\r\nconst { parseTl, serializeBytes, serializeDate, } = require(\"./generationHelpers\");\r\nconst { toSignedLittleBuffer } = require(\"../Helpers\");\r\nconst NAMED_AUTO_CASTS = new Set([\"chatId,int\"]);\r\nconst NAMED_BLACKLIST = new Set([\"discardEncryption\"]);\r\nconst AUTO_CASTS = new Set([\r\n    \"InputPeer\",\r\n    \"InputChannel\",\r\n    \"InputUser\",\r\n    \"InputDialogPeer\",\r\n    \"InputNotifyPeer\",\r\n    \"InputMedia\",\r\n    \"InputPhoto\",\r\n    \"InputMessage\",\r\n    \"InputDocument\",\r\n    \"InputChatPhoto\",\r\n]);\r\nclass CastError extends Error {\r\n    constructor(objectName, expected, actual, ...params) {\r\n        // Pass remaining arguments (including vendor specific ones) to parent constructor\r\n        const message = \"Found wrong type for \" +\r\n            objectName +\r\n            \". expected \" +\r\n            expected +\r\n            \" but received \" +\r\n            actual +\r\n            \".If you think this is a mistake please report it.\";\r\n        super(message, ...params);\r\n        // Maintains proper stack trace for where our error was thrown (only available on V8)\r\n        if (Error.captureStackTrace) {\r\n            Error.captureStackTrace(this, CastError);\r\n        }\r\n        this.name = \"CastError\";\r\n        // Custom debugging information\r\n    }\r\n}\r\nconst CACHING_SUPPORTED = typeof self !== \"undefined\" && self.localStorage !== undefined;\r\nconst CACHE_KEY = \"GramJs:apiCache\";\r\nfunction buildApiFromTlSchema() {\r\n    let definitions;\r\n    const fromCache = CACHING_SUPPORTED && loadFromCache();\r\n    if (fromCache) {\r\n        definitions = fromCache;\r\n    }\r\n    else {\r\n        definitions = loadFromTlSchemas();\r\n        if (CACHING_SUPPORTED) {\r\n            localStorage.setItem(CACHE_KEY, JSON.stringify(definitions));\r\n        }\r\n    }\r\n    return createClasses(\"all\", definitions);\r\n}\r\nfunction loadFromCache() {\r\n    const jsonCache = localStorage.getItem(CACHE_KEY);\r\n    return jsonCache && JSON.parse(jsonCache);\r\n}\r\nfunction loadFromTlSchemas() {\r\n    const [constructorParamsApi, functionParamsApi] = extractParams(tlContent);\r\n    const [constructorParamsSchema, functionParamsSchema] = extractParams(schemeContent);\r\n    const constructors = [].concat(constructorParamsApi, constructorParamsSchema);\r\n    const requests = [].concat(functionParamsApi, functionParamsSchema);\r\n    return [].concat(constructors, requests);\r\n}\r\nfunction extractParams(fileContent) {\r\n    const f = parseTl(fileContent, 109);\r\n    const constructors = [];\r\n    const functions = [];\r\n    for (const d of f) {\r\n        d.isFunction ? functions.push(d) : constructors.push(d);\r\n    }\r\n    return [constructors, functions];\r\n}\r\nfunction argToBytes(x, type, argName, requestName) {\r\n    switch (type) {\r\n        case \"int\":\r\n            const i = buffer_1.Buffer.alloc(4);\r\n            i.writeInt32LE(x, 0);\r\n            return i;\r\n        case \"long\":\r\n            return toSignedLittleBuffer(x, 8);\r\n        case \"int128\":\r\n            return toSignedLittleBuffer(x, 16);\r\n        case \"int256\":\r\n            return toSignedLittleBuffer(x, 32);\r\n        case \"double\":\r\n            const d = buffer_1.Buffer.alloc(8);\r\n            d.writeDoubleLE(x, 0);\r\n            return d;\r\n        case \"string\":\r\n            return serializeBytes(x);\r\n        case \"Bool\":\r\n            return x\r\n                ? buffer_1.Buffer.from(\"b5757299\", \"hex\")\r\n                : buffer_1.Buffer.from(\"379779bc\", \"hex\");\r\n        case \"true\":\r\n            return buffer_1.Buffer.alloc(0);\r\n        case \"bytes\":\r\n            return serializeBytes(x);\r\n        case \"date\":\r\n            return serializeDate(x);\r\n        default:\r\n            if (x === undefined || typeof x.getBytes !== \"function\") {\r\n                throw new Error(`Required object ${argName} of ${requestName} is undefined`);\r\n            }\r\n            return x.getBytes();\r\n    }\r\n}\r\nasync function getInputFromResolve(utils, client, peer, peerType) {\r\n    switch (peerType) {\r\n        case \"InputPeer\":\r\n            return utils.getInputPeer(await client.getInputEntity(peer));\r\n        case \"InputChannel\":\r\n            return utils.getInputChannel(await client.getInputEntity(peer));\r\n        case \"InputUser\":\r\n            return utils.getInputUser(await client.getInputEntity(peer));\r\n        case \"InputDialogPeer\":\r\n            return await client._getInputDialog(peer);\r\n        case \"InputNotifyPeer\":\r\n            return await client._getInputNotify(peer);\r\n        case \"InputMedia\":\r\n            return utils.getInputMedia(peer);\r\n        case \"InputPhoto\":\r\n            return utils.getInputPhoto(peer);\r\n        case \"InputMessage\":\r\n            return utils.getInputMessage(peer);\r\n        case \"InputDocument\":\r\n            return utils.getInputDocument(peer);\r\n        case \"InputChatPhoto\":\r\n            return utils.getInputChatPhoto(peer);\r\n        case \"chatId,int\":\r\n            return await client.getPeerId(peer, false);\r\n        default:\r\n            throw new Error(\"unsupported peer type : \" + peerType);\r\n    }\r\n}\r\nfunction getArgFromReader(reader, arg) {\r\n    if (arg.isVector) {\r\n        if (arg.useVectorId) {\r\n            reader.readInt();\r\n        }\r\n        const temp = [];\r\n        const len = reader.readInt();\r\n        arg.isVector = false;\r\n        for (let i = 0; i < len; i++) {\r\n            temp.push(getArgFromReader(reader, arg));\r\n        }\r\n        arg.isVector = true;\r\n        return temp;\r\n    }\r\n    else if (arg.flagIndicator) {\r\n        return reader.readInt();\r\n    }\r\n    else {\r\n        switch (arg.type) {\r\n            case \"int\":\r\n                return reader.readInt();\r\n            case \"long\":\r\n                return reader.readLong();\r\n            case \"int128\":\r\n                return reader.readLargeInt(128);\r\n            case \"int256\":\r\n                return reader.readLargeInt(256);\r\n            case \"double\":\r\n                return reader.readDouble();\r\n            case \"string\":\r\n                return reader.tgReadString();\r\n            case \"Bool\":\r\n                return reader.tgReadBool();\r\n            case \"true\":\r\n                return true;\r\n            case \"bytes\":\r\n                return reader.tgReadBytes();\r\n            case \"date\":\r\n                return reader.tgReadDate();\r\n            default:\r\n                if (!arg.skipConstructorId) {\r\n                    return reader.tgReadObject();\r\n                }\r\n                else {\r\n                    return api.constructors[arg.type].fromReader(reader);\r\n                }\r\n        }\r\n    }\r\n}\r\nfunction compareType(value, type) {\r\n    let correct = true;\r\n    switch (type) {\r\n        case \"number\":\r\n            correct = typeof value === \"number\" || value === undefined;\r\n            break;\r\n        case \"string\":\r\n        case \"boolean\":\r\n            correct = typeof value === type;\r\n            break;\r\n        case \"bigInt\":\r\n            correct =\r\n                bigInt.isInstance(value) ||\r\n                    typeof value === \"bigint\" ||\r\n                    typeof value === \"number\" ||\r\n                    typeof value === \"string\" ||\r\n                    value === undefined;\r\n            break;\r\n        case \"true\":\r\n            // true value is always correct\r\n            break;\r\n        case \"buffer\":\r\n            correct = buffer_1.Buffer.isBuffer(value);\r\n            break;\r\n        case \"date\":\r\n            correct =\r\n                (value &&\r\n                    Object.prototype.toString.call(value) === \"[object Date]\" &&\r\n                    !isNaN(value)) ||\r\n                    typeof value === \"number\";\r\n            break;\r\n        default:\r\n            console.error(new Error(\"Unknown type.\" + type));\r\n    }\r\n    return correct;\r\n}\r\nfunction createClasses(classesType, params) {\r\n    const classes = {};\r\n    for (const classParams of params) {\r\n        const { name, constructorId, subclassOfId, argsConfig, namespace, isFunction, result, } = classParams;\r\n        const fullName = [namespace, name].join(\".\").replace(/^\\./, \"\");\r\n        class VirtualClass {\r\n            constructor(args) {\r\n                this.CONSTRUCTOR_ID = constructorId;\r\n                this.SUBCLASS_OF_ID = subclassOfId;\r\n                this.className = fullName;\r\n                this.classType = isFunction ? \"request\" : \"constructor\";\r\n                args = args || {};\r\n                this.originalArgs = args;\r\n                this.init(args);\r\n                for (const argName in argsConfig) {\r\n                    if (argName === \"randomId\" && !args[argName]) {\r\n                        if (argsConfig[argName].isVector) {\r\n                            const rands = [];\r\n                            for (let i = 0; i < args[\"id\"].length; i++) {\r\n                                rands.push(generateRandomBigInt());\r\n                            }\r\n                            this[argName] = rands;\r\n                        }\r\n                        else {\r\n                            this[argName] = generateRandomBigInt();\r\n                        }\r\n                    }\r\n                    else {\r\n                        this[argName] = args[argName];\r\n                    }\r\n                }\r\n            }\r\n            init(args) { }\r\n            static fromReader(reader) {\r\n                const args = {};\r\n                for (const argName in argsConfig) {\r\n                    if (argsConfig.hasOwnProperty(argName)) {\r\n                        const arg = argsConfig[argName];\r\n                        if (arg.isFlag) {\r\n                            if (arg.type === \"true\") {\r\n                                args[argName] = Boolean(args[arg.flagName] & (1 << arg.flagIndex));\r\n                                continue;\r\n                            }\r\n                            if (args[arg.flagName] & (1 << arg.flagIndex)) {\r\n                                args[argName] = getArgFromReader(reader, arg);\r\n                            }\r\n                            else {\r\n                                args[argName] = null;\r\n                            }\r\n                        }\r\n                        else {\r\n                            if (arg.flagIndicator) {\r\n                                arg.name = argName;\r\n                            }\r\n                            args[argName] = getArgFromReader(reader, arg);\r\n                        }\r\n                    }\r\n                }\r\n                return new this(args);\r\n            }\r\n            validate() {\r\n                for (const arg in argsConfig) {\r\n                    if (argsConfig.hasOwnProperty(arg)) {\r\n                        if (argsConfig[arg].flagIndicator ||\r\n                            argsConfig[arg].isFlag) {\r\n                            // we don't care about flags\r\n                            continue;\r\n                        }\r\n                        const currentValue = this[arg];\r\n                        this.assertType(arg, argsConfig[arg], currentValue);\r\n                    }\r\n                }\r\n            }\r\n            assertType(objectName, object, value) {\r\n                let expected;\r\n                if (object[\"isVector\"]) {\r\n                    if (!isArrayLike(value)) {\r\n                        console.error(new CastError(objectName, \"array\", value));\r\n                    }\r\n                    if (value == undefined) {\r\n                        value = [];\r\n                    }\r\n                    for (const o of value) {\r\n                        this.assertType(objectName, Object.assign(Object.assign({}, object), { isVector: false }), o);\r\n                    }\r\n                }\r\n                else {\r\n                    switch (object[\"type\"]) {\r\n                        case \"int\":\r\n                            expected = \"number\";\r\n                            break;\r\n                        case \"long\":\r\n                        case \"int128\":\r\n                        case \"int256\":\r\n                            expected = \"bigInt\";\r\n                            break;\r\n                        case \"double\":\r\n                            expected = \"number\";\r\n                            break;\r\n                        case \"string\":\r\n                            expected = \"string\";\r\n                            break;\r\n                        case \"Bool\":\r\n                            expected = \"boolean\";\r\n                            break;\r\n                        case \"true\":\r\n                            expected = \"true\";\r\n                            break;\r\n                        case \"bytes\":\r\n                            expected = \"buffer\";\r\n                            break;\r\n                        case \"date\":\r\n                            expected = \"date\";\r\n                            break;\r\n                        default:\r\n                            expected = \"object\";\r\n                    }\r\n                    if (expected === \"object\") {\r\n                        // will be validated in get byte();\r\n                    }\r\n                    else {\r\n                        const isCorrectType = compareType(value, expected);\r\n                        if (isCorrectType !== true) {\r\n                            console.error(new CastError(objectName, expected, value));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            getBytes() {\r\n                try {\r\n                    this.validate();\r\n                }\r\n                catch (e) {\r\n                    // feature still in alpha so errors are expected.\r\n                }\r\n                const idForBytes = this.CONSTRUCTOR_ID;\r\n                const c = buffer_1.Buffer.alloc(4);\r\n                c.writeUInt32LE(idForBytes, 0);\r\n                const buffers = [c];\r\n                for (const arg in argsConfig) {\r\n                    if (argsConfig.hasOwnProperty(arg)) {\r\n                        if (argsConfig[arg].isFlag) {\r\n                            if ((this[arg] === false &&\r\n                                argsConfig[arg].type !== \"Bool\") ||\r\n                                this[arg] === null ||\r\n                                this[arg] === undefined ||\r\n                                argsConfig[arg].type === \"true\") {\r\n                                continue;\r\n                            }\r\n                        }\r\n                        if (argsConfig[arg].isVector) {\r\n                            if (argsConfig[arg].useVectorId) {\r\n                                buffers.push(buffer_1.Buffer.from(\"15c4b51c\", \"hex\"));\r\n                            }\r\n                            const l = buffer_1.Buffer.alloc(4);\r\n                            l.writeInt32LE(this[arg].length, 0);\r\n                            buffers.push(l, buffer_1.Buffer.concat(this[arg].map((x) => argToBytes(x, argsConfig[arg].type, fullName))));\r\n                        }\r\n                        else if (argsConfig[arg].flagIndicator) {\r\n                            if (!Object.values(argsConfig).some((f) => f.isFlag)) {\r\n                                buffers.push(buffer_1.Buffer.alloc(4));\r\n                            }\r\n                            else {\r\n                                let flagCalculate = 0;\r\n                                for (const f in argsConfig) {\r\n                                    if (argsConfig[f].isFlag &&\r\n                                        arg === argsConfig[f].flagName) {\r\n                                        if ((this[f] === false &&\r\n                                            argsConfig[f].type !==\r\n                                                \"Bool\") ||\r\n                                            this[f] === undefined ||\r\n                                            this[f] === null) {\r\n                                            flagCalculate |= 0;\r\n                                        }\r\n                                        else {\r\n                                            flagCalculate |=\r\n                                                1 << argsConfig[f].flagIndex;\r\n                                        }\r\n                                    }\r\n                                }\r\n                                const f = buffer_1.Buffer.alloc(4);\r\n                                f.writeUInt32LE(flagCalculate, 0);\r\n                                buffers.push(f);\r\n                            }\r\n                        }\r\n                        else {\r\n                            buffers.push(argToBytes(this[arg], argsConfig[arg].type, arg, fullName));\r\n                            if (this[arg] &&\r\n                                typeof this[arg].getBytes === \"function\") {\r\n                                let boxed = argsConfig[arg].type.charAt(argsConfig[arg].type.indexOf(\".\") + 1);\r\n                                boxed = boxed === boxed.toUpperCase();\r\n                                if (!boxed) {\r\n                                    buffers.shift();\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                return buffer_1.Buffer.concat(buffers);\r\n            }\r\n            readResult(reader) {\r\n                if (!isFunction) {\r\n                    throw new Error(\"`readResult()` called for non-request instance\");\r\n                }\r\n                const m = result.match(/Vector<(int|long)>/);\r\n                if (m) {\r\n                    reader.readInt();\r\n                    const temp = [];\r\n                    const len = reader.readInt();\r\n                    if (m[1] === \"int\") {\r\n                        for (let i = 0; i < len; i++) {\r\n                            temp.push(reader.readInt());\r\n                        }\r\n                    }\r\n                    else {\r\n                        for (let i = 0; i < len; i++) {\r\n                            temp.push(reader.readLong());\r\n                        }\r\n                    }\r\n                    return temp;\r\n                }\r\n                else {\r\n                    return reader.tgReadObject();\r\n                }\r\n            }\r\n            async resolve(client, utils) {\r\n                if (!isFunction) {\r\n                    throw new Error(\"`resolve()` called for non-request instance\");\r\n                }\r\n                for (const arg in argsConfig) {\r\n                    if (argsConfig.hasOwnProperty(arg)) {\r\n                        if (!AUTO_CASTS.has(argsConfig[arg].type)) {\r\n                            if (!NAMED_AUTO_CASTS.has(`${argsConfig[arg].name},${argsConfig[arg].type}`)) {\r\n                                continue;\r\n                            }\r\n                        }\r\n                        if (argsConfig[arg].isFlag) {\r\n                            if (!this[arg]) {\r\n                                continue;\r\n                            }\r\n                        }\r\n                        if (argsConfig[arg].isVector) {\r\n                            const temp = [];\r\n                            for (const x of this[arg]) {\r\n                                temp.push(await getInputFromResolve(utils, client, x, argsConfig[arg].type));\r\n                            }\r\n                            this[arg] = temp;\r\n                        }\r\n                        else {\r\n                            this[arg] = await getInputFromResolve(utils, client, this[arg], argsConfig[arg].type);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            [inspect.custom]() {\r\n                return betterConsoleLog(this);\r\n            }\r\n            toJSON() {\r\n                return Object.assign(Object.assign({}, this.originalArgs), { className: fullName });\r\n            }\r\n        }\r\n        VirtualClass.CONSTRUCTOR_ID = constructorId;\r\n        VirtualClass.SUBCLASS_OF_ID = subclassOfId;\r\n        VirtualClass.className = fullName;\r\n        VirtualClass.classType = isFunction ? \"request\" : \"constructor\";\r\n        if (namespace) {\r\n            if (!classes[namespace]) {\r\n                classes[namespace] = {};\r\n            }\r\n            classes[namespace][name] = VirtualClass;\r\n        }\r\n        else {\r\n            classes[name] = VirtualClass;\r\n        }\r\n    }\r\n    return classes;\r\n}\r\nconst api = buildApiFromTlSchema();\r\nmodule.exports = { Api: api };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}