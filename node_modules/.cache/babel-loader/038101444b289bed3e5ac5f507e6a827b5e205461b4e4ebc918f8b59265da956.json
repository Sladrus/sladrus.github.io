{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.updateTwoFaSettings = void 0;\nvar buffer_1 = require(\"buffer/\");\nvar Helpers_1 = require(\"../Helpers\");\nvar Password_1 = require(\"../Password\");\nvar tl_1 = require(\"../tl\");\nvar index_1 = require(\"../index\");\n/**\r\n * Changes the 2FA settings of the logged in user.\r\n Note that this method may be *incredibly* slow depending on the\r\n prime numbers that must be used during the process to make sure\r\n that everything is safe.\r\n\r\n Has no effect if both current and new password are omitted.\r\n\r\n * @param client: The telegram client instance\r\n * @param isCheckPassword: Must be ``true`` if you want to check the current password\r\n * @param currentPassword: The current password, to authorize changing to ``new_password``.\r\n Must be set if changing existing 2FA settings.\r\n Must **not** be set if 2FA is currently disabled.\r\n Passing this by itself will remove 2FA (if correct).\r\n * @param newPassword: The password to set as 2FA.\r\n If 2FA was already enabled, ``currentPassword`` **must** be set.\r\n Leaving this blank or `undefined` will remove the password.\r\n * @param hint: Hint to be displayed by Telegram when it asks for 2FA.\r\n Must be set when changing or creating a new password.\r\n Has no effect if ``newPassword`` is not set.\r\n * @param email: Recovery and verification email. If present, you must also\r\n set `emailCodeCallback`, else it raises an Error.\r\n * @param emailCodeCallback: If an email is provided, a callback that returns the code sent\r\n to it must also be set. This callback may be asynchronous.\r\n It should return a string with the code. The length of the\r\n code will be passed to the callback as an input parameter.\r\n * @param onEmailCodeError: Called when an error happens while sending an email.\r\n\r\n If the callback returns an invalid code, it will raise an rpc error with the message\r\n ``CODE_INVALID``\r\n\r\n * @returns Promise<void>\r\n * @throws this method can throw:\r\n \"PASSWORD_HASH_INVALID\" if you entered a wrong password (or set it to undefined).\r\n \"EMAIL_INVALID\" if the entered email is wrong\r\n \"EMAIL_HASH_EXPIRED\" if the user took too long to verify their email\r\n */\nfunction updateTwoFaSettings(_x, _x2) {\n  return _updateTwoFaSettings.apply(this, arguments);\n}\nfunction _updateTwoFaSettings() {\n  _updateTwoFaSettings = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(client, _ref) {\n    var isCheckPassword, currentPassword, newPassword, _ref$hint, hint, email, emailCodeCallback, onEmailCodeError, pwd, password, code;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          isCheckPassword = _ref.isCheckPassword, currentPassword = _ref.currentPassword, newPassword = _ref.newPassword, _ref$hint = _ref.hint, hint = _ref$hint === void 0 ? \"\" : _ref$hint, email = _ref.email, emailCodeCallback = _ref.emailCodeCallback, onEmailCodeError = _ref.onEmailCodeError;\n          if (!(!newPassword && !currentPassword)) {\n            _context.next = 3;\n            break;\n          }\n          throw new Error(\"Neither `currentPassword` nor `newPassword` is present\");\n        case 3:\n          if (!(email && !(emailCodeCallback && onEmailCodeError))) {\n            _context.next = 5;\n            break;\n          }\n          throw new Error(\"`email` present without `emailCodeCallback` and `onEmailCodeError`\");\n        case 5:\n          _context.next = 7;\n          return client.invoke(new tl_1.Api.account.GetPassword());\n        case 7:\n          pwd = _context.sent;\n          if (!(pwd.newAlgo instanceof tl_1.Api.PasswordKdfAlgoUnknown)) {\n            pwd.newAlgo.salt1 = buffer_1.Buffer.concat([pwd.newAlgo.salt1, (0, Helpers_1.generateRandomBytes)(32)]);\n          }\n          if (!pwd.hasPassword && currentPassword) {\n            currentPassword = undefined;\n          }\n          if (!currentPassword) {\n            _context.next = 16;\n            break;\n          }\n          _context.next = 13;\n          return (0, Password_1.computeCheck)(pwd, currentPassword);\n        case 13:\n          _context.t0 = _context.sent;\n          _context.next = 17;\n          break;\n        case 16:\n          _context.t0 = new tl_1.Api.InputCheckPasswordEmpty();\n        case 17:\n          password = _context.t0;\n          if (!isCheckPassword) {\n            _context.next = 22;\n            break;\n          }\n          _context.next = 21;\n          return client.invoke(new tl_1.Api.auth.CheckPassword({\n            password: password\n          }));\n        case 21:\n          return _context.abrupt(\"return\");\n        case 22:\n          if (!(pwd.newAlgo instanceof tl_1.Api.PasswordKdfAlgoUnknown)) {\n            _context.next = 24;\n            break;\n          }\n          throw new Error(\"Unknown password encryption method\");\n        case 24:\n          _context.prev = 24;\n          _context.t1 = client;\n          _context.t2 = tl_1.Api.account.UpdatePasswordSettings;\n          _context.t3 = password;\n          _context.t4 = tl_1.Api.account.PasswordInputSettings;\n          _context.t5 = pwd.newAlgo;\n          if (!newPassword) {\n            _context.next = 36;\n            break;\n          }\n          _context.next = 33;\n          return (0, Password_1.computeDigest)(pwd.newAlgo, newPassword);\n        case 33:\n          _context.t6 = _context.sent;\n          _context.next = 37;\n          break;\n        case 36:\n          _context.t6 = buffer_1.Buffer.alloc(0);\n        case 37:\n          _context.t7 = _context.t6;\n          _context.t8 = hint;\n          _context.t9 = email;\n          _context.t10 = undefined;\n          _context.t11 = {\n            newAlgo: _context.t5,\n            newPasswordHash: _context.t7,\n            hint: _context.t8,\n            email: _context.t9,\n            newSecureSettings: _context.t10\n          };\n          _context.t12 = new _context.t4(_context.t11);\n          _context.t13 = {\n            password: _context.t3,\n            newSettings: _context.t12\n          };\n          _context.t14 = new _context.t2(_context.t13);\n          _context.next = 47;\n          return _context.t1.invoke.call(_context.t1, _context.t14);\n        case 47:\n          _context.next = 72;\n          break;\n        case 49:\n          _context.prev = 49;\n          _context.t15 = _context[\"catch\"](24);\n          if (!(_context.t15 instanceof index_1.errors.EmailUnconfirmedError)) {\n            _context.next = 71;\n            break;\n          }\n        case 52:\n          if (!true) {\n            _context.next = 69;\n            break;\n          }\n          _context.prev = 53;\n          _context.next = 56;\n          return emailCodeCallback(_context.t15.codeLength);\n        case 56:\n          code = _context.sent;\n          if (code) {\n            _context.next = 59;\n            break;\n          }\n          throw new Error(\"Code is empty\");\n        case 59:\n          _context.next = 61;\n          return client.invoke(new tl_1.Api.account.ConfirmPasswordEmail({\n            code: code\n          }));\n        case 61:\n          return _context.abrupt(\"break\", 69);\n        case 64:\n          _context.prev = 64;\n          _context.t16 = _context[\"catch\"](53);\n          onEmailCodeError(_context.t16);\n        case 67:\n          _context.next = 52;\n          break;\n        case 69:\n          _context.next = 72;\n          break;\n        case 71:\n          throw _context.t15;\n        case 72:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee, null, [[24, 49], [53, 64]]);\n  }));\n  return _updateTwoFaSettings.apply(this, arguments);\n}\nexports.updateTwoFaSettings = updateTwoFaSettings;","map":{"version":3,"names":["Object","defineProperty","exports","value","updateTwoFaSettings","buffer_1","require","Helpers_1","Password_1","tl_1","index_1","client","isCheckPassword","currentPassword","newPassword","hint","email","emailCodeCallback","onEmailCodeError","Error","invoke","Api","account","GetPassword","pwd","newAlgo","PasswordKdfAlgoUnknown","salt1","Buffer","concat","generateRandomBytes","hasPassword","undefined","computeCheck","InputCheckPasswordEmpty","password","auth","CheckPassword","UpdatePasswordSettings","PasswordInputSettings","computeDigest","alloc","newPasswordHash","newSecureSettings","newSettings","errors","EmailUnconfirmedError","codeLength","code","ConfirmPasswordEmail"],"sources":["C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/telegram/client/2fa.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.updateTwoFaSettings = void 0;\r\nconst buffer_1 = require(\"buffer/\");\r\nconst Helpers_1 = require(\"../Helpers\");\r\nconst Password_1 = require(\"../Password\");\r\nconst tl_1 = require(\"../tl\");\r\nconst index_1 = require(\"../index\");\r\n/**\r\n * Changes the 2FA settings of the logged in user.\r\n Note that this method may be *incredibly* slow depending on the\r\n prime numbers that must be used during the process to make sure\r\n that everything is safe.\r\n\r\n Has no effect if both current and new password are omitted.\r\n\r\n * @param client: The telegram client instance\r\n * @param isCheckPassword: Must be ``true`` if you want to check the current password\r\n * @param currentPassword: The current password, to authorize changing to ``new_password``.\r\n Must be set if changing existing 2FA settings.\r\n Must **not** be set if 2FA is currently disabled.\r\n Passing this by itself will remove 2FA (if correct).\r\n * @param newPassword: The password to set as 2FA.\r\n If 2FA was already enabled, ``currentPassword`` **must** be set.\r\n Leaving this blank or `undefined` will remove the password.\r\n * @param hint: Hint to be displayed by Telegram when it asks for 2FA.\r\n Must be set when changing or creating a new password.\r\n Has no effect if ``newPassword`` is not set.\r\n * @param email: Recovery and verification email. If present, you must also\r\n set `emailCodeCallback`, else it raises an Error.\r\n * @param emailCodeCallback: If an email is provided, a callback that returns the code sent\r\n to it must also be set. This callback may be asynchronous.\r\n It should return a string with the code. The length of the\r\n code will be passed to the callback as an input parameter.\r\n * @param onEmailCodeError: Called when an error happens while sending an email.\r\n\r\n If the callback returns an invalid code, it will raise an rpc error with the message\r\n ``CODE_INVALID``\r\n\r\n * @returns Promise<void>\r\n * @throws this method can throw:\r\n \"PASSWORD_HASH_INVALID\" if you entered a wrong password (or set it to undefined).\r\n \"EMAIL_INVALID\" if the entered email is wrong\r\n \"EMAIL_HASH_EXPIRED\" if the user took too long to verify their email\r\n */\r\nasync function updateTwoFaSettings(client, { isCheckPassword, currentPassword, newPassword, hint = \"\", email, emailCodeCallback, onEmailCodeError, }) {\r\n    if (!newPassword && !currentPassword) {\r\n        throw new Error(\"Neither `currentPassword` nor `newPassword` is present\");\r\n    }\r\n    if (email && !(emailCodeCallback && onEmailCodeError)) {\r\n        throw new Error(\"`email` present without `emailCodeCallback` and `onEmailCodeError`\");\r\n    }\r\n    const pwd = await client.invoke(new tl_1.Api.account.GetPassword());\r\n    if (!(pwd.newAlgo instanceof tl_1.Api.PasswordKdfAlgoUnknown)) {\r\n        pwd.newAlgo.salt1 = buffer_1.Buffer.concat([\r\n            pwd.newAlgo.salt1,\r\n            (0, Helpers_1.generateRandomBytes)(32),\r\n        ]);\r\n    }\r\n    if (!pwd.hasPassword && currentPassword) {\r\n        currentPassword = undefined;\r\n    }\r\n    const password = currentPassword\r\n        ? await (0, Password_1.computeCheck)(pwd, currentPassword)\r\n        : new tl_1.Api.InputCheckPasswordEmpty();\r\n    if (isCheckPassword) {\r\n        await client.invoke(new tl_1.Api.auth.CheckPassword({ password }));\r\n        return;\r\n    }\r\n    if (pwd.newAlgo instanceof tl_1.Api.PasswordKdfAlgoUnknown) {\r\n        throw new Error(\"Unknown password encryption method\");\r\n    }\r\n    try {\r\n        await client.invoke(new tl_1.Api.account.UpdatePasswordSettings({\r\n            password,\r\n            newSettings: new tl_1.Api.account.PasswordInputSettings({\r\n                newAlgo: pwd.newAlgo,\r\n                newPasswordHash: newPassword\r\n                    ? await (0, Password_1.computeDigest)(pwd.newAlgo, newPassword)\r\n                    : buffer_1.Buffer.alloc(0),\r\n                hint,\r\n                email,\r\n                // not explained what it does and it seems to always be set to empty in tdesktop\r\n                newSecureSettings: undefined,\r\n            }),\r\n        }));\r\n    }\r\n    catch (e) {\r\n        if (e instanceof index_1.errors.EmailUnconfirmedError) {\r\n            // eslint-disable-next-line no-constant-condition\r\n            while (true) {\r\n                try {\r\n                    const code = await emailCodeCallback(e.codeLength);\r\n                    if (!code) {\r\n                        throw new Error(\"Code is empty\");\r\n                    }\r\n                    await client.invoke(new tl_1.Api.account.ConfirmPasswordEmail({ code }));\r\n                    break;\r\n                }\r\n                catch (err) {\r\n                    onEmailCodeError(err);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            throw e;\r\n        }\r\n    }\r\n}\r\nexports.updateTwoFaSettings = updateTwoFaSettings;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}