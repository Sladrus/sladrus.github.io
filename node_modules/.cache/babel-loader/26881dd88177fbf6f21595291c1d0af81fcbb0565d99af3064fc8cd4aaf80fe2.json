{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _createForOfIteratorHelper = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MessagePacker = void 0;\nvar buffer_1 = require(\"buffer/\");\nvar core_1 = require(\"../tl/core\");\nvar core_2 = require(\"../tl/core\");\nvar BinaryWriter_1 = require(\"./BinaryWriter\");\nvar MessagePacker = /*#__PURE__*/function () {\n  function MessagePacker(state, logger) {\n    var _this = this;\n    _classCallCheck(this, MessagePacker);\n    this._state = state;\n    this._queue = [];\n    this._pendingStates = [];\n    this._ready = new Promise(function (resolve) {\n      _this.setReady = resolve;\n    });\n    this._log = logger;\n  }\n  _createClass(MessagePacker, [{\n    key: \"values\",\n    value: function values() {\n      return this._queue;\n    }\n  }, {\n    key: \"append\",\n    value: function append(state) {\n      this._queue.push(state);\n      if (this.setReady) {\n        this.setReady(true);\n      }\n    }\n  }, {\n    key: \"extend\",\n    value: function extend(states) {\n      var _iterator = _createForOfIteratorHelper(states),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var state = _step.value;\n          this.append(state);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _this2 = this;\n        var data, buffer, batch, size, state, afterId, b, containerId, _iterator2, _step2, s;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (this._queue.length) {\n                _context.next = 4;\n                break;\n              }\n              this._ready = new Promise(function (resolve) {\n                _this2.setReady = resolve;\n              });\n              _context.next = 4;\n              return this._ready;\n            case 4:\n              buffer = new BinaryWriter_1.BinaryWriter(buffer_1.Buffer.alloc(0));\n              batch = [];\n              size = 0;\n            case 7:\n              if (!(this._queue.length && batch.length <= core_1.MessageContainer.MAXIMUM_LENGTH)) {\n                _context.next = 27;\n                break;\n              }\n              state = this._queue.shift();\n              size += state.data.length + core_2.TLMessage.SIZE_OVERHEAD;\n              if (!(size <= core_1.MessageContainer.MAXIMUM_SIZE)) {\n                _context.next = 19;\n                break;\n              }\n              afterId = void 0;\n              if (state.after) {\n                afterId = state.after.msgId;\n              }\n              _context.next = 15;\n              return this._state.writeDataAsMessage(buffer, state.data, state.request.classType === \"request\", afterId);\n            case 15:\n              state.msgId = _context.sent;\n              this._log.debug(\"Assigned msgId = \".concat(state.msgId, \" to \").concat(state.request.className || state.request.constructor.name));\n              batch.push(state);\n              return _context.abrupt(\"continue\", 7);\n            case 19:\n              if (!batch.length) {\n                _context.next = 22;\n                break;\n              }\n              this._queue.unshift(state);\n              return _context.abrupt(\"break\", 27);\n            case 22:\n              this._log.warn(\"Message payload for \".concat(state.request.className || state.request.constructor.name, \" is too long \").concat(state.data.length, \" and cannot be sent\"));\n              state.promise.reject(\"Request Payload is too big\");\n              size = 0;\n              _context.next = 7;\n              break;\n            case 27:\n              if (batch.length) {\n                _context.next = 29;\n                break;\n              }\n              return _context.abrupt(\"return\", null);\n            case 29:\n              if (!(batch.length > 1)) {\n                _context.next = 40;\n                break;\n              }\n              b = buffer_1.Buffer.alloc(8);\n              b.writeUInt32LE(core_1.MessageContainer.CONSTRUCTOR_ID, 0);\n              b.writeInt32LE(batch.length, 4);\n              data = buffer_1.Buffer.concat([b, buffer.getValue()]);\n              buffer = new BinaryWriter_1.BinaryWriter(buffer_1.Buffer.alloc(0));\n              _context.next = 37;\n              return this._state.writeDataAsMessage(buffer, data, false);\n            case 37:\n              containerId = _context.sent;\n              _iterator2 = _createForOfIteratorHelper(batch);\n              try {\n                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                  s = _step2.value;\n                  s.containerId = containerId;\n                }\n              } catch (err) {\n                _iterator2.e(err);\n              } finally {\n                _iterator2.f();\n              }\n            case 40:\n              data = buffer.getValue();\n              return _context.abrupt(\"return\", {\n                batch: batch,\n                data: data\n              });\n            case 42:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function get() {\n        return _get.apply(this, arguments);\n      }\n      return get;\n    }()\n  }, {\n    key: \"rejectAll\",\n    value: function rejectAll() {\n      this._pendingStates.forEach(function (requestState) {\n        var _a;\n        requestState.reject(new Error(\"Disconnect (caused from \" + ((_a = requestState === null || requestState === void 0 ? void 0 : requestState.request) === null || _a === void 0 ? void 0 : _a.className) + \")\"));\n      });\n    }\n  }]);\n  return MessagePacker;\n}();\nexports.MessagePacker = MessagePacker;","map":{"version":3,"names":["Object","defineProperty","exports","value","MessagePacker","buffer_1","require","core_1","core_2","BinaryWriter_1","state","logger","_state","_queue","_pendingStates","_ready","Promise","resolve","setReady","_log","push","states","append","length","buffer","BinaryWriter","Buffer","alloc","batch","size","MessageContainer","MAXIMUM_LENGTH","shift","data","TLMessage","SIZE_OVERHEAD","MAXIMUM_SIZE","afterId","after","msgId","writeDataAsMessage","request","classType","debug","className","constructor","name","unshift","warn","promise","reject","b","writeUInt32LE","CONSTRUCTOR_ID","writeInt32LE","concat","getValue","containerId","s","forEach","requestState","_a","Error"],"sources":["C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/telegram/extensions/MessagePacker.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.MessagePacker = void 0;\r\nconst buffer_1 = require(\"buffer/\");\r\nconst core_1 = require(\"../tl/core\");\r\nconst core_2 = require(\"../tl/core\");\r\nconst BinaryWriter_1 = require(\"./BinaryWriter\");\r\nclass MessagePacker {\r\n    constructor(state, logger) {\r\n        this._state = state;\r\n        this._queue = [];\r\n        this._pendingStates = [];\r\n        this._ready = new Promise((resolve) => {\r\n            this.setReady = resolve;\r\n        });\r\n        this._log = logger;\r\n    }\r\n    values() {\r\n        return this._queue;\r\n    }\r\n    append(state) {\r\n        this._queue.push(state);\r\n        if (this.setReady) {\r\n            this.setReady(true);\r\n        }\r\n    }\r\n    extend(states) {\r\n        for (const state of states) {\r\n            this.append(state);\r\n        }\r\n    }\r\n    async get() {\r\n        if (!this._queue.length) {\r\n            this._ready = new Promise((resolve) => {\r\n                this.setReady = resolve;\r\n            });\r\n            await this._ready;\r\n        }\r\n        let data;\r\n        let buffer = new BinaryWriter_1.BinaryWriter(buffer_1.Buffer.alloc(0));\r\n        const batch = [];\r\n        let size = 0;\r\n        while (this._queue.length &&\r\n            batch.length <= core_1.MessageContainer.MAXIMUM_LENGTH) {\r\n            const state = this._queue.shift();\r\n            size += state.data.length + core_2.TLMessage.SIZE_OVERHEAD;\r\n            if (size <= core_1.MessageContainer.MAXIMUM_SIZE) {\r\n                let afterId;\r\n                if (state.after) {\r\n                    afterId = state.after.msgId;\r\n                }\r\n                state.msgId = await this._state.writeDataAsMessage(buffer, state.data, state.request.classType === \"request\", afterId);\r\n                this._log.debug(`Assigned msgId = ${state.msgId} to ${state.request.className ||\r\n                    state.request.constructor.name}`);\r\n                batch.push(state);\r\n                continue;\r\n            }\r\n            if (batch.length) {\r\n                this._queue.unshift(state);\r\n                break;\r\n            }\r\n            this._log.warn(`Message payload for ${state.request.className || state.request.constructor.name} is too long ${state.data.length} and cannot be sent`);\r\n            state.promise.reject(\"Request Payload is too big\");\r\n            size = 0;\r\n        }\r\n        if (!batch.length) {\r\n            return null;\r\n        }\r\n        if (batch.length > 1) {\r\n            const b = buffer_1.Buffer.alloc(8);\r\n            b.writeUInt32LE(core_1.MessageContainer.CONSTRUCTOR_ID, 0);\r\n            b.writeInt32LE(batch.length, 4);\r\n            data = buffer_1.Buffer.concat([b, buffer.getValue()]);\r\n            buffer = new BinaryWriter_1.BinaryWriter(buffer_1.Buffer.alloc(0));\r\n            const containerId = await this._state.writeDataAsMessage(buffer, data, false);\r\n            for (const s of batch) {\r\n                s.containerId = containerId;\r\n            }\r\n        }\r\n        data = buffer.getValue();\r\n        return { batch, data };\r\n    }\r\n    rejectAll() {\r\n        this._pendingStates.forEach((requestState) => {\r\n            var _a;\r\n            requestState.reject(new Error(\"Disconnect (caused from \" +\r\n                ((_a = requestState === null || requestState === void 0 ? void 0 : requestState.request) === null || _a === void 0 ? void 0 : _a.className) +\r\n                \")\"));\r\n        });\r\n    }\r\n}\r\nexports.MessagePacker = MessagePacker;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}