{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _defineProperty = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nvar _slicedToArray = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createForOfIteratorHelper = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.variableSnakeToCamelCase = exports.snakeToCamelCase = exports.CORE_TYPES = exports.fromLine = exports.buildArgConfig = exports.parseTl = exports.findAll = exports.serializeDate = exports.serializeBytes = void 0;\nvar buffer_1 = require(\"buffer/\");\nvar Helpers_1 = require(\"../Helpers\");\nvar snakeToCamelCase = function snakeToCamelCase(name) {\n  var result = name.replace(/(?:^|_)([a-z])/g, function (_, g) {\n    return g.toUpperCase();\n  });\n  return result.replace(/_/g, \"\");\n};\nexports.snakeToCamelCase = snakeToCamelCase;\nvar variableSnakeToCamelCase = function variableSnakeToCamelCase(str) {\n  return str.replace(/([-_][a-z])/g, function (group) {\n    return group.toUpperCase().replace(\"-\", \"\").replace(\"_\", \"\");\n  });\n};\nexports.variableSnakeToCamelCase = variableSnakeToCamelCase;\nvar CORE_TYPES = new Set([0xbc799737, 0x997275b5, 0x3fedd339, 0xc4b9f9bb, 0x56730bcc // null#56730bcc = Null;\n]);\n\nexports.CORE_TYPES = CORE_TYPES;\nvar AUTH_KEY_TYPES = new Set([0x05162463, 0x83c95aec, 0xa9f55f95, 0x3c6a84d4, 0x56fddf88, 0xd0e8075c, 0xb5890dba, 0x6643b654, 0xd712e4be, 0xf5045f1f, 0x3072cfa1 // gzip_packed\n]);\n\nvar fromLine = function fromLine(line, isFunction) {\n  var match = line.match(/([\\w.]+)(?:#([0-9a-fA-F]+))?(?:\\s{?\\w+:[\\w\\d<>#.?!]+}?)*\\s=\\s([\\w\\d<>#.?]+);$/);\n  if (!match) {\n    // Probably \"vector#1cb5c415 {t:Type} # [ t ] = Vector t;\"\n    throw new Error(\"Cannot parse TLObject \".concat(line));\n  }\n  var argsMatch = findAll(/({)?(\\w+):([\\w\\d<>#.?!]+)}?/, line);\n  var currentConfig = {\n    name: match[1],\n    constructorId: parseInt(match[2], 16),\n    argsConfig: {},\n    subclassOfId: (0, Helpers_1.crc32)(match[3]),\n    result: match[3],\n    isFunction: isFunction,\n    namespace: undefined\n  };\n  if (!currentConfig.constructorId) {\n    var hexId = \"\";\n    var args;\n    if (Object.values(currentConfig.argsConfig).length) {\n      args = \" \".concat(Object.keys(currentConfig.argsConfig).map(function (arg) {\n        return arg.toString();\n      }).join(\" \"));\n    } else {\n      args = \"\";\n    }\n    var representation = \"\".concat(currentConfig.name).concat(hexId).concat(args, \" = \").concat(currentConfig.result).replace(/(:|\\?)bytes /g, \"$1string \").replace(/</g, \" \").replace(/>|{|}/g, \"\").replace(/ \\w+:flags(\\d+)?\\.\\d+\\?true/g, \"\");\n    if (currentConfig.name === \"inputMediaInvoice\") {\n      // eslint-disable-next-line no-empty\n      if (currentConfig.name === \"inputMediaInvoice\") {}\n    }\n    currentConfig.constructorId = (0, Helpers_1.crc32)(buffer_1.Buffer.from(representation, \"utf8\"));\n  }\n  var _iterator = _createForOfIteratorHelper(argsMatch),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 3),\n        brace = _step$value[0],\n        name = _step$value[1],\n        argType = _step$value[2];\n      if (brace === undefined) {\n        // @ts-ignore\n        currentConfig.argsConfig[variableSnakeToCamelCase(name)] = buildArgConfig(name, argType);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  if (currentConfig.name.includes(\".\")) {\n    var _currentConfig$name$s = currentConfig.name.split(/\\.(.+)/);\n    var _currentConfig$name$s2 = _slicedToArray(_currentConfig$name$s, 2);\n    currentConfig.namespace = _currentConfig$name$s2[0];\n    currentConfig.name = _currentConfig$name$s2[1];\n  }\n  currentConfig.name = snakeToCamelCase(currentConfig.name);\n  /*\r\n  for (const arg in currentConfig.argsConfig){\r\n    if (currentConfig.argsConfig.hasOwnProperty(arg)){\r\n      if (currentConfig.argsConfig[arg].flagIndicator){\r\n        delete  currentConfig.argsConfig[arg]\r\n      }\r\n    }\r\n  }*/\n  return currentConfig;\n};\nexports.fromLine = fromLine;\nfunction buildArgConfig(name, argType) {\n  name = name === \"self\" ? \"is_self\" : name;\n  // Default values\n  var currentConfig = {\n    isVector: false,\n    isFlag: false,\n    skipConstructorId: false,\n    flagName: null,\n    flagIndex: -1,\n    flagIndicator: true,\n    type: null,\n    useVectorId: null\n  };\n  // Special case: some types can be inferred, which makes it\n  // less annoying to type. Currently the only type that can\n  // be inferred is if the name is 'random_id', to which a\n  // random ID will be assigned if left as None (the default)\n  var canBeInferred = name === \"random_id\";\n  // The type can be an indicator that other arguments will be flags\n  if (argType !== \"#\") {\n    currentConfig.flagIndicator = false;\n    // Strip the exclamation mark always to have only the name\n    currentConfig.type = argType.replace(/^!+/, \"\");\n    // The type may be a flag (flags.IDX?REAL_TYPE)\n    // Note that 'flags' is NOT the flags name; this\n    // is determined by a previous argument\n    // However, we assume that the argument will always be starts with 'flags'\n    // @ts-ignore\n    var flagMatch = currentConfig.type.match(/(flags(?:\\d+)?).(\\d+)\\?([\\w<>.]+)/);\n    if (flagMatch) {\n      currentConfig.isFlag = true;\n      // As of layer 140, flagName can be \"flags\" or \"flags2\"\n      currentConfig.flagName = flagMatch[1];\n      currentConfig.flagIndex = Number(flagMatch[2]);\n      // Update the type to match the exact type, not the \"flagged\" one\n      currentConfig.type = flagMatch[3];\n    }\n    // Then check if the type is a Vector<REAL_TYPE>\n    // @ts-ignore\n    var vectorMatch = currentConfig.type.match(/[Vv]ector<([\\w\\d.]+)>/);\n    if (vectorMatch) {\n      currentConfig.isVector = true;\n      // If the type's first letter is not uppercase, then\n      // it is a constructor and we use (read/write) its ID.\n      // @ts-ignore\n      currentConfig.useVectorId = currentConfig.type.charAt(0) === \"V\";\n      // Update the type to match the one inside the vector\n      var _vectorMatch = _slicedToArray(vectorMatch, 2);\n      currentConfig.type = _vectorMatch[1];\n    }\n    // See use_vector_id. An example of such case is ipPort in\n    // help.configSpecial\n    // @ts-ignore\n    if (/^[a-z]$/.test(currentConfig.type.split(\".\").pop().charAt(0))) {\n      currentConfig.skipConstructorId = true;\n    }\n    // The name may contain \"date\" in it, if this is the case and\n    // the type is \"int\", we can safely assume that this should be\n    // treated as a \"date\" object. Note that this is not a valid\n    // Telegram object, but it's easier to work with\n    // if (\n    //     this.type === 'int' &&\n    //     (/(\\b|_)([dr]ate|until|since)(\\b|_)/.test(name) ||\n    //         ['expires', 'expires_at', 'was_online'].includes(name))\n    // ) {\n    //     this.type = 'date';\n    // }\n  }\n  // workaround\n  if (currentConfig.type == \"future_salt\") {\n    currentConfig.type = \"FutureSalt\";\n  }\n  return currentConfig;\n}\nexports.buildArgConfig = buildArgConfig;\nvar parseTl = function parseTl(content, layer) {\n  var methods = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var ignoreIds = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : CORE_TYPES;\n  return /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var methodInfo, objAll, objByName, objByType, file, isFunction, _iterator2, _step2, line, commentIndex, match, _match, followingTypes, result, _i, _objAll, obj, arg, _i2, _objAll2, _obj;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          methodInfo = (methods || []).reduce(function (o, m) {\n            return Object.assign(Object.assign({}, o), _defineProperty({}, m.name, m));\n          }, {});\n          objAll = [];\n          objByName = {};\n          objByType = {};\n          file = content;\n          isFunction = false;\n          _iterator2 = _createForOfIteratorHelper(file.split(\"\\n\"));\n          _context.prev = 7;\n          _iterator2.s();\n        case 9:\n          if ((_step2 = _iterator2.n()).done) {\n            _context.next = 35;\n            break;\n          }\n          line = _step2.value;\n          commentIndex = line.indexOf(\"//\");\n          if (commentIndex !== -1) {\n            line = line.slice(0, commentIndex);\n          }\n          line = line.trim();\n          if (line) {\n            _context.next = 16;\n            break;\n          }\n          return _context.abrupt(\"continue\", 33);\n        case 16:\n          match = line.match(/---(\\w+)---/);\n          if (!match) {\n            _context.next = 21;\n            break;\n          }\n          _match = _slicedToArray(match, 2), followingTypes = _match[1];\n          isFunction = followingTypes === \"functions\";\n          return _context.abrupt(\"continue\", 33);\n        case 21:\n          _context.prev = 21;\n          result = fromLine(line, isFunction);\n          if (!ignoreIds.has(result.constructorId)) {\n            _context.next = 25;\n            break;\n          }\n          return _context.abrupt(\"continue\", 33);\n        case 25:\n          objAll.push(result);\n          if (!result.isFunction) {\n            if (!objByType[result.result]) {\n              objByType[result.result] = [];\n            }\n            objByName[result.name] = result;\n            objByType[result.result].push(result);\n          }\n          _context.next = 33;\n          break;\n        case 29:\n          _context.prev = 29;\n          _context.t0 = _context[\"catch\"](21);\n          if (_context.t0.toString().includes(\"vector#1cb5c415\")) {\n            _context.next = 33;\n            break;\n          }\n          throw _context.t0;\n        case 33:\n          _context.next = 9;\n          break;\n        case 35:\n          _context.next = 40;\n          break;\n        case 37:\n          _context.prev = 37;\n          _context.t1 = _context[\"catch\"](7);\n          _iterator2.e(_context.t1);\n        case 40:\n          _context.prev = 40;\n          _iterator2.f();\n          return _context.finish(40);\n        case 43:\n          // Once all objects have been parsed, replace the\n          // string type from the arguments with references\n          for (_i = 0, _objAll = objAll; _i < _objAll.length; _i++) {\n            obj = _objAll[_i];\n            if (AUTH_KEY_TYPES.has(obj.constructorId)) {\n              for (arg in obj.argsConfig) {\n                if (obj.argsConfig[arg].type === \"string\") {\n                  obj.argsConfig[arg].type = \"bytes\";\n                }\n              }\n            }\n          }\n          _i2 = 0, _objAll2 = objAll;\n        case 45:\n          if (!(_i2 < _objAll2.length)) {\n            _context.next = 52;\n            break;\n          }\n          _obj = _objAll2[_i2];\n          _context.next = 49;\n          return _obj;\n        case 49:\n          _i2++;\n          _context.next = 45;\n          break;\n        case 52:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee, null, [[7, 37, 40, 43], [21, 29]]);\n  })();\n};\nexports.parseTl = parseTl;\nvar findAll = function findAll(regex, str) {\n  var matches = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  if (!regex.flags.includes(\"g\")) {\n    regex = new RegExp(regex.source, \"g\");\n  }\n  var res = regex.exec(str);\n  if (res) {\n    matches.push(res.slice(1));\n    findAll(regex, str, matches);\n  }\n  return matches;\n};\nexports.findAll = findAll;\nfunction serializeBytes(data) {\n  if (!(data instanceof buffer_1.Buffer)) {\n    if (typeof data == \"string\") {\n      data = buffer_1.Buffer.from(data);\n    } else {\n      throw Error(\"Bytes or str expected, not \".concat(data.constructor.name));\n    }\n  }\n  var r = [];\n  var padding;\n  if (data.length < 254) {\n    padding = (data.length + 1) % 4;\n    if (padding !== 0) {\n      padding = 4 - padding;\n    }\n    r.push(buffer_1.Buffer.from([data.length]));\n    r.push(data);\n  } else {\n    padding = data.length % 4;\n    if (padding !== 0) {\n      padding = 4 - padding;\n    }\n    r.push(buffer_1.Buffer.from([254, data.length % 256, (data.length >> 8) % 256, (data.length >> 16) % 256]));\n    r.push(data);\n  }\n  r.push(buffer_1.Buffer.alloc(padding).fill(0));\n  return buffer_1.Buffer.concat(r);\n}\nexports.serializeBytes = serializeBytes;\nfunction serializeDate(dt) {\n  if (!dt) {\n    return buffer_1.Buffer.alloc(4).fill(0);\n  }\n  if (dt instanceof Date) {\n    dt = Math.floor((Date.now() - dt.getTime()) / 1000);\n  }\n  if (typeof dt == \"number\") {\n    var t = buffer_1.Buffer.alloc(4);\n    t.writeInt32LE(dt, 0);\n    return t;\n  }\n  throw Error(\"Cannot interpret \\\"\".concat(dt, \"\\\" as a date\"));\n}\nexports.serializeDate = serializeDate;","map":{"version":3,"names":["Object","defineProperty","exports","value","variableSnakeToCamelCase","snakeToCamelCase","CORE_TYPES","fromLine","buildArgConfig","parseTl","findAll","serializeDate","serializeBytes","buffer_1","require","Helpers_1","name","result","replace","_","g","toUpperCase","str","group","Set","AUTH_KEY_TYPES","line","isFunction","match","Error","argsMatch","currentConfig","constructorId","parseInt","argsConfig","subclassOfId","crc32","namespace","undefined","hexId","args","values","length","keys","map","arg","toString","join","representation","Buffer","from","brace","argType","includes","split","isVector","isFlag","skipConstructorId","flagName","flagIndex","flagIndicator","type","useVectorId","canBeInferred","flagMatch","Number","vectorMatch","charAt","test","pop","content","layer","methods","ignoreIds","methodInfo","reduce","o","m","assign","objAll","objByName","objByType","file","commentIndex","indexOf","slice","trim","followingTypes","has","push","obj","regex","matches","flags","RegExp","source","res","exec","data","constructor","r","padding","alloc","fill","concat","dt","Date","Math","floor","now","getTime","t","writeInt32LE"],"sources":["C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/telegram/tl/generationHelpers.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.variableSnakeToCamelCase = exports.snakeToCamelCase = exports.CORE_TYPES = exports.fromLine = exports.buildArgConfig = exports.parseTl = exports.findAll = exports.serializeDate = exports.serializeBytes = void 0;\r\nconst buffer_1 = require(\"buffer/\");\r\nconst Helpers_1 = require(\"../Helpers\");\r\nconst snakeToCamelCase = (name) => {\r\n    const result = name.replace(/(?:^|_)([a-z])/g, (_, g) => g.toUpperCase());\r\n    return result.replace(/_/g, \"\");\r\n};\r\nexports.snakeToCamelCase = snakeToCamelCase;\r\nconst variableSnakeToCamelCase = (str) => str.replace(/([-_][a-z])/g, (group) => group.toUpperCase().replace(\"-\", \"\").replace(\"_\", \"\"));\r\nexports.variableSnakeToCamelCase = variableSnakeToCamelCase;\r\nconst CORE_TYPES = new Set([\r\n    0xbc799737,\r\n    0x997275b5,\r\n    0x3fedd339,\r\n    0xc4b9f9bb,\r\n    0x56730bcc, // null#56730bcc = Null;\r\n]);\r\nexports.CORE_TYPES = CORE_TYPES;\r\nconst AUTH_KEY_TYPES = new Set([\r\n    0x05162463,\r\n    0x83c95aec,\r\n    0xa9f55f95,\r\n    0x3c6a84d4,\r\n    0x56fddf88,\r\n    0xd0e8075c,\r\n    0xb5890dba,\r\n    0x6643b654,\r\n    0xd712e4be,\r\n    0xf5045f1f,\r\n    0x3072cfa1, // gzip_packed\r\n]);\r\nconst fromLine = (line, isFunction) => {\r\n    const match = line.match(/([\\w.]+)(?:#([0-9a-fA-F]+))?(?:\\s{?\\w+:[\\w\\d<>#.?!]+}?)*\\s=\\s([\\w\\d<>#.?]+);$/);\r\n    if (!match) {\r\n        // Probably \"vector#1cb5c415 {t:Type} # [ t ] = Vector t;\"\r\n        throw new Error(`Cannot parse TLObject ${line}`);\r\n    }\r\n    const argsMatch = findAll(/({)?(\\w+):([\\w\\d<>#.?!]+)}?/, line);\r\n    const currentConfig = {\r\n        name: match[1],\r\n        constructorId: parseInt(match[2], 16),\r\n        argsConfig: {},\r\n        subclassOfId: (0, Helpers_1.crc32)(match[3]),\r\n        result: match[3],\r\n        isFunction: isFunction,\r\n        namespace: undefined,\r\n    };\r\n    if (!currentConfig.constructorId) {\r\n        const hexId = \"\";\r\n        let args;\r\n        if (Object.values(currentConfig.argsConfig).length) {\r\n            args = ` ${Object.keys(currentConfig.argsConfig)\r\n                .map((arg) => arg.toString())\r\n                .join(\" \")}`;\r\n        }\r\n        else {\r\n            args = \"\";\r\n        }\r\n        const representation = `${currentConfig.name}${hexId}${args} = ${currentConfig.result}`\r\n            .replace(/(:|\\?)bytes /g, \"$1string \")\r\n            .replace(/</g, \" \")\r\n            .replace(/>|{|}/g, \"\")\r\n            .replace(/ \\w+:flags(\\d+)?\\.\\d+\\?true/g, \"\");\r\n        if (currentConfig.name === \"inputMediaInvoice\") {\r\n            // eslint-disable-next-line no-empty\r\n            if (currentConfig.name === \"inputMediaInvoice\") {\r\n            }\r\n        }\r\n        currentConfig.constructorId = (0, Helpers_1.crc32)(buffer_1.Buffer.from(representation, \"utf8\"));\r\n    }\r\n    for (const [brace, name, argType] of argsMatch) {\r\n        if (brace === undefined) {\r\n            // @ts-ignore\r\n            currentConfig.argsConfig[variableSnakeToCamelCase(name)] =\r\n                buildArgConfig(name, argType);\r\n        }\r\n    }\r\n    if (currentConfig.name.includes(\".\")) {\r\n        [currentConfig.namespace, currentConfig.name] =\r\n            currentConfig.name.split(/\\.(.+)/);\r\n    }\r\n    currentConfig.name = snakeToCamelCase(currentConfig.name);\r\n    /*\r\n    for (const arg in currentConfig.argsConfig){\r\n      if (currentConfig.argsConfig.hasOwnProperty(arg)){\r\n        if (currentConfig.argsConfig[arg].flagIndicator){\r\n          delete  currentConfig.argsConfig[arg]\r\n        }\r\n      }\r\n    }*/\r\n    return currentConfig;\r\n};\r\nexports.fromLine = fromLine;\r\nfunction buildArgConfig(name, argType) {\r\n    name = name === \"self\" ? \"is_self\" : name;\r\n    // Default values\r\n    const currentConfig = {\r\n        isVector: false,\r\n        isFlag: false,\r\n        skipConstructorId: false,\r\n        flagName: null,\r\n        flagIndex: -1,\r\n        flagIndicator: true,\r\n        type: null,\r\n        useVectorId: null,\r\n    };\r\n    // Special case: some types can be inferred, which makes it\r\n    // less annoying to type. Currently the only type that can\r\n    // be inferred is if the name is 'random_id', to which a\r\n    // random ID will be assigned if left as None (the default)\r\n    const canBeInferred = name === \"random_id\";\r\n    // The type can be an indicator that other arguments will be flags\r\n    if (argType !== \"#\") {\r\n        currentConfig.flagIndicator = false;\r\n        // Strip the exclamation mark always to have only the name\r\n        currentConfig.type = argType.replace(/^!+/, \"\");\r\n        // The type may be a flag (flags.IDX?REAL_TYPE)\r\n        // Note that 'flags' is NOT the flags name; this\r\n        // is determined by a previous argument\r\n        // However, we assume that the argument will always be starts with 'flags'\r\n        // @ts-ignore\r\n        const flagMatch = currentConfig.type.match(/(flags(?:\\d+)?).(\\d+)\\?([\\w<>.]+)/);\r\n        if (flagMatch) {\r\n            currentConfig.isFlag = true;\r\n            // As of layer 140, flagName can be \"flags\" or \"flags2\"\r\n            currentConfig.flagName = flagMatch[1];\r\n            currentConfig.flagIndex = Number(flagMatch[2]);\r\n            // Update the type to match the exact type, not the \"flagged\" one\r\n            currentConfig.type = flagMatch[3];\r\n        }\r\n        // Then check if the type is a Vector<REAL_TYPE>\r\n        // @ts-ignore\r\n        const vectorMatch = currentConfig.type.match(/[Vv]ector<([\\w\\d.]+)>/);\r\n        if (vectorMatch) {\r\n            currentConfig.isVector = true;\r\n            // If the type's first letter is not uppercase, then\r\n            // it is a constructor and we use (read/write) its ID.\r\n            // @ts-ignore\r\n            currentConfig.useVectorId = currentConfig.type.charAt(0) === \"V\";\r\n            // Update the type to match the one inside the vector\r\n            [, currentConfig.type] = vectorMatch;\r\n        }\r\n        // See use_vector_id. An example of such case is ipPort in\r\n        // help.configSpecial\r\n        // @ts-ignore\r\n        if (/^[a-z]$/.test(currentConfig.type.split(\".\").pop().charAt(0))) {\r\n            currentConfig.skipConstructorId = true;\r\n        }\r\n        // The name may contain \"date\" in it, if this is the case and\r\n        // the type is \"int\", we can safely assume that this should be\r\n        // treated as a \"date\" object. Note that this is not a valid\r\n        // Telegram object, but it's easier to work with\r\n        // if (\r\n        //     this.type === 'int' &&\r\n        //     (/(\\b|_)([dr]ate|until|since)(\\b|_)/.test(name) ||\r\n        //         ['expires', 'expires_at', 'was_online'].includes(name))\r\n        // ) {\r\n        //     this.type = 'date';\r\n        // }\r\n    }\r\n    // workaround\r\n    if (currentConfig.type == \"future_salt\") {\r\n        currentConfig.type = \"FutureSalt\";\r\n    }\r\n    return currentConfig;\r\n}\r\nexports.buildArgConfig = buildArgConfig;\r\nconst parseTl = function* (content, layer, methods = [], ignoreIds = CORE_TYPES) {\r\n    const methodInfo = (methods || []).reduce((o, m) => (Object.assign(Object.assign({}, o), { [m.name]: m })), {});\r\n    const objAll = [];\r\n    const objByName = {};\r\n    const objByType = {};\r\n    const file = content;\r\n    let isFunction = false;\r\n    for (let line of file.split(\"\\n\")) {\r\n        const commentIndex = line.indexOf(\"//\");\r\n        if (commentIndex !== -1) {\r\n            line = line.slice(0, commentIndex);\r\n        }\r\n        line = line.trim();\r\n        if (!line) {\r\n            continue;\r\n        }\r\n        const match = line.match(/---(\\w+)---/);\r\n        if (match) {\r\n            const [, followingTypes] = match;\r\n            isFunction = followingTypes === \"functions\";\r\n            continue;\r\n        }\r\n        try {\r\n            const result = fromLine(line, isFunction);\r\n            if (ignoreIds.has(result.constructorId)) {\r\n                continue;\r\n            }\r\n            objAll.push(result);\r\n            if (!result.isFunction) {\r\n                if (!objByType[result.result]) {\r\n                    objByType[result.result] = [];\r\n                }\r\n                objByName[result.name] = result;\r\n                objByType[result.result].push(result);\r\n            }\r\n        }\r\n        catch (e) {\r\n            if (!e.toString().includes(\"vector#1cb5c415\")) {\r\n                throw e;\r\n            }\r\n        }\r\n    }\r\n    // Once all objects have been parsed, replace the\r\n    // string type from the arguments with references\r\n    for (const obj of objAll) {\r\n        if (AUTH_KEY_TYPES.has(obj.constructorId)) {\r\n            for (const arg in obj.argsConfig) {\r\n                if (obj.argsConfig[arg].type === \"string\") {\r\n                    obj.argsConfig[arg].type = \"bytes\";\r\n                }\r\n            }\r\n        }\r\n    }\r\n    for (const obj of objAll) {\r\n        yield obj;\r\n    }\r\n};\r\nexports.parseTl = parseTl;\r\nconst findAll = (regex, str, matches = []) => {\r\n    if (!regex.flags.includes(\"g\")) {\r\n        regex = new RegExp(regex.source, \"g\");\r\n    }\r\n    const res = regex.exec(str);\r\n    if (res) {\r\n        matches.push(res.slice(1));\r\n        findAll(regex, str, matches);\r\n    }\r\n    return matches;\r\n};\r\nexports.findAll = findAll;\r\nfunction serializeBytes(data) {\r\n    if (!(data instanceof buffer_1.Buffer)) {\r\n        if (typeof data == \"string\") {\r\n            data = buffer_1.Buffer.from(data);\r\n        }\r\n        else {\r\n            throw Error(`Bytes or str expected, not ${data.constructor.name}`);\r\n        }\r\n    }\r\n    const r = [];\r\n    let padding;\r\n    if (data.length < 254) {\r\n        padding = (data.length + 1) % 4;\r\n        if (padding !== 0) {\r\n            padding = 4 - padding;\r\n        }\r\n        r.push(buffer_1.Buffer.from([data.length]));\r\n        r.push(data);\r\n    }\r\n    else {\r\n        padding = data.length % 4;\r\n        if (padding !== 0) {\r\n            padding = 4 - padding;\r\n        }\r\n        r.push(buffer_1.Buffer.from([\r\n            254,\r\n            data.length % 256,\r\n            (data.length >> 8) % 256,\r\n            (data.length >> 16) % 256,\r\n        ]));\r\n        r.push(data);\r\n    }\r\n    r.push(buffer_1.Buffer.alloc(padding).fill(0));\r\n    return buffer_1.Buffer.concat(r);\r\n}\r\nexports.serializeBytes = serializeBytes;\r\nfunction serializeDate(dt) {\r\n    if (!dt) {\r\n        return buffer_1.Buffer.alloc(4).fill(0);\r\n    }\r\n    if (dt instanceof Date) {\r\n        dt = Math.floor((Date.now() - dt.getTime()) / 1000);\r\n    }\r\n    if (typeof dt == \"number\") {\r\n        const t = buffer_1.Buffer.alloc(4);\r\n        t.writeInt32LE(dt, 0);\r\n        return t;\r\n    }\r\n    throw Error(`Cannot interpret \"${dt}\" as a date`);\r\n}\r\nexports.serializeDate = serializeDate;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}