{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MTProtoPlainSender = void 0;\nvar buffer_1 = require(\"buffer/\");\n/**\r\n *  This module contains the class used to communicate with Telegram's servers\r\n *  in plain text, when no authorization key has been created yet.\r\n */\nvar big_integer_1 = __importDefault(require(\"big-integer\"));\nvar MTProtoState_1 = require(\"./MTProtoState\");\nvar Helpers_1 = require(\"../Helpers\");\nvar errors_1 = require(\"../errors\");\nvar extensions_1 = require(\"../extensions\");\n/**\r\n * MTProto Mobile Protocol plain sender (https://core.telegram.org/mtproto/description#unencrypted-messages)\r\n */\nvar MTProtoPlainSender = /*#__PURE__*/function () {\n  /**\r\n   * Initializes the MTProto plain sender.\r\n   * @param connection connection: the Connection to be used.\r\n   * @param loggers\r\n   */\n  function MTProtoPlainSender(connection, loggers) {\n    _classCallCheck(this, MTProtoPlainSender);\n    this._state = new MTProtoState_1.MTProtoState(undefined, loggers);\n    this._connection = connection;\n  }\n  /**\r\n   * Sends and receives the result for the given request.\r\n   * @param request\r\n   */\n  _createClass(MTProtoPlainSender, [{\n    key: \"send\",\n    value: function () {\n      var _send = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {\n        var body, msgId, m, b, res, reader, authKeyId, length;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              body = request.getBytes();\n              msgId = this._state._getNewMsgId();\n              m = (0, Helpers_1.toSignedLittleBuffer)(msgId, 8);\n              b = buffer_1.Buffer.alloc(4);\n              b.writeInt32LE(body.length, 0);\n              res = buffer_1.Buffer.concat([buffer_1.Buffer.concat([buffer_1.Buffer.alloc(8), m, b]), body]);\n              _context.next = 8;\n              return this._connection.send(res);\n            case 8:\n              _context.next = 10;\n              return this._connection.recv();\n            case 10:\n              body = _context.sent;\n              if (!(body.length < 8)) {\n                _context.next = 13;\n                break;\n              }\n              throw new errors_1.InvalidBufferError(body);\n            case 13:\n              reader = new extensions_1.BinaryReader(body);\n              authKeyId = reader.readLong();\n              if (!authKeyId.neq((0, big_integer_1.default)(0))) {\n                _context.next = 17;\n                break;\n              }\n              throw new Error(\"Bad authKeyId\");\n            case 17:\n              msgId = reader.readLong();\n              if (!msgId.eq((0, big_integer_1.default)(0))) {\n                _context.next = 20;\n                break;\n              }\n              throw new Error(\"Bad msgId\");\n            case 20:\n              /** ^ We should make sure that the read ``msg_id`` is greater\r\n               * than our own ``msg_id``. However, under some circumstances\r\n               * (bad system clock/working behind proxies) this seems to not\r\n               * be the case, which would cause endless assertion errors.\r\n               */\n              length = reader.readInt();\n              if (!(length <= 0)) {\n                _context.next = 23;\n                break;\n              }\n              throw new Error(\"Bad length\");\n            case 23:\n              return _context.abrupt(\"return\", reader.tgReadObject());\n            case 24:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function send(_x) {\n        return _send.apply(this, arguments);\n      }\n      return send;\n    }()\n  }]);\n  return MTProtoPlainSender;\n}();\nexports.MTProtoPlainSender = MTProtoPlainSender;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","MTProtoPlainSender","buffer_1","require","big_integer_1","MTProtoState_1","Helpers_1","errors_1","extensions_1","connection","loggers","_state","MTProtoState","undefined","_connection","request","body","getBytes","msgId","_getNewMsgId","m","toSignedLittleBuffer","b","Buffer","alloc","writeInt32LE","length","res","concat","send","recv","InvalidBufferError","reader","BinaryReader","authKeyId","readLong","neq","default","Error","eq","readInt","tgReadObject"],"sources":["C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/telegram/network/MTProtoPlainSender.js"],"sourcesContent":["\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.MTProtoPlainSender = void 0;\r\nconst buffer_1 = require(\"buffer/\");\r\n/**\r\n *  This module contains the class used to communicate with Telegram's servers\r\n *  in plain text, when no authorization key has been created yet.\r\n */\r\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\r\nconst MTProtoState_1 = require(\"./MTProtoState\");\r\nconst Helpers_1 = require(\"../Helpers\");\r\nconst errors_1 = require(\"../errors\");\r\nconst extensions_1 = require(\"../extensions\");\r\n/**\r\n * MTProto Mobile Protocol plain sender (https://core.telegram.org/mtproto/description#unencrypted-messages)\r\n */\r\nclass MTProtoPlainSender {\r\n    /**\r\n     * Initializes the MTProto plain sender.\r\n     * @param connection connection: the Connection to be used.\r\n     * @param loggers\r\n     */\r\n    constructor(connection, loggers) {\r\n        this._state = new MTProtoState_1.MTProtoState(undefined, loggers);\r\n        this._connection = connection;\r\n    }\r\n    /**\r\n     * Sends and receives the result for the given request.\r\n     * @param request\r\n     */\r\n    async send(request) {\r\n        let body = request.getBytes();\r\n        let msgId = this._state._getNewMsgId();\r\n        const m = (0, Helpers_1.toSignedLittleBuffer)(msgId, 8);\r\n        const b = buffer_1.Buffer.alloc(4);\r\n        b.writeInt32LE(body.length, 0);\r\n        const res = buffer_1.Buffer.concat([\r\n            buffer_1.Buffer.concat([buffer_1.Buffer.alloc(8), m, b]),\r\n            body,\r\n        ]);\r\n        await this._connection.send(res);\r\n        body = await this._connection.recv();\r\n        if (body.length < 8) {\r\n            throw new errors_1.InvalidBufferError(body);\r\n        }\r\n        const reader = new extensions_1.BinaryReader(body);\r\n        const authKeyId = reader.readLong();\r\n        if (authKeyId.neq((0, big_integer_1.default)(0))) {\r\n            throw new Error(\"Bad authKeyId\");\r\n        }\r\n        msgId = reader.readLong();\r\n        if (msgId.eq((0, big_integer_1.default)(0))) {\r\n            throw new Error(\"Bad msgId\");\r\n        }\r\n        /** ^ We should make sure that the read ``msg_id`` is greater\r\n         * than our own ``msg_id``. However, under some circumstances\r\n         * (bad system clock/working behind proxies) this seems to not\r\n         * be the case, which would cause endless assertion errors.\r\n         */\r\n        const length = reader.readInt();\r\n        if (length <= 0) {\r\n            throw new Error(\"Bad length\");\r\n        }\r\n        /**\r\n         * We could read length bytes and use those in a new reader to read\r\n         * the next TLObject without including the padding, but since the\r\n         * reader isn't used for anything else after this, it's unnecessary.\r\n         */\r\n        return reader.tgReadObject();\r\n    }\r\n}\r\nexports.MTProtoPlainSender = MTProtoPlainSender;\r\n"],"mappings":"AAAA,YAAY;;AAAC;AAAA;AAAA;AAAA;AACb,IAAIA,eAAe,GAAI,IAAI,IAAI,IAAI,CAACA,eAAe,IAAK,UAAUC,GAAG,EAAE;EACnE,OAAQA,GAAG,IAAIA,GAAG,CAACC,UAAU,GAAID,GAAG,GAAG;IAAE,SAAS,EAAEA;EAAI,CAAC;AAC7D,CAAC;AACDE,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,kBAAkB,GAAG,KAAK,CAAC;AACnC,IAAMC,QAAQ,GAAGC,OAAO,CAAC,SAAS,CAAC;AACnC;AACA;AACA;AACA;AACA,IAAMC,aAAa,GAAGV,eAAe,CAACS,OAAO,CAAC,aAAa,CAAC,CAAC;AAC7D,IAAME,cAAc,GAAGF,OAAO,CAAC,gBAAgB,CAAC;AAChD,IAAMG,SAAS,GAAGH,OAAO,CAAC,YAAY,CAAC;AACvC,IAAMI,QAAQ,GAAGJ,OAAO,CAAC,WAAW,CAAC;AACrC,IAAMK,YAAY,GAAGL,OAAO,CAAC,eAAe,CAAC;AAC7C;AACA;AACA;AAFA,IAGMF,kBAAkB;EACpB;AACJ;AACA;AACA;AACA;EACI,4BAAYQ,UAAU,EAAEC,OAAO,EAAE;IAAA;IAC7B,IAAI,CAACC,MAAM,GAAG,IAAIN,cAAc,CAACO,YAAY,CAACC,SAAS,EAAEH,OAAO,CAAC;IACjE,IAAI,CAACI,WAAW,GAAGL,UAAU;EACjC;EACA;AACJ;AACA;AACA;EAHI;IAAA;IAAA;MAAA,uEAIA,iBAAWM,OAAO;QAAA;QAAA;UAAA;YAAA;cACVC,IAAI,GAAGD,OAAO,CAACE,QAAQ,EAAE;cACzBC,KAAK,GAAG,IAAI,CAACP,MAAM,CAACQ,YAAY,EAAE;cAChCC,CAAC,GAAG,CAAC,CAAC,EAAEd,SAAS,CAACe,oBAAoB,EAAEH,KAAK,EAAE,CAAC,CAAC;cACjDI,CAAC,GAAGpB,QAAQ,CAACqB,MAAM,CAACC,KAAK,CAAC,CAAC,CAAC;cAClCF,CAAC,CAACG,YAAY,CAACT,IAAI,CAACU,MAAM,EAAE,CAAC,CAAC;cACxBC,GAAG,GAAGzB,QAAQ,CAACqB,MAAM,CAACK,MAAM,CAAC,CAC/B1B,QAAQ,CAACqB,MAAM,CAACK,MAAM,CAAC,CAAC1B,QAAQ,CAACqB,MAAM,CAACC,KAAK,CAAC,CAAC,CAAC,EAAEJ,CAAC,EAAEE,CAAC,CAAC,CAAC,EACxDN,IAAI,CACP,CAAC;cAAA;cAAA,OACI,IAAI,CAACF,WAAW,CAACe,IAAI,CAACF,GAAG,CAAC;YAAA;cAAA;cAAA,OACnB,IAAI,CAACb,WAAW,CAACgB,IAAI,EAAE;YAAA;cAApCd,IAAI;cAAA,MACAA,IAAI,CAACU,MAAM,GAAG,CAAC;gBAAA;gBAAA;cAAA;cAAA,MACT,IAAInB,QAAQ,CAACwB,kBAAkB,CAACf,IAAI,CAAC;YAAA;cAEzCgB,MAAM,GAAG,IAAIxB,YAAY,CAACyB,YAAY,CAACjB,IAAI,CAAC;cAC5CkB,SAAS,GAAGF,MAAM,CAACG,QAAQ,EAAE;cAAA,KAC/BD,SAAS,CAACE,GAAG,CAAC,CAAC,CAAC,EAAEhC,aAAa,CAACiC,OAAO,EAAE,CAAC,CAAC,CAAC;gBAAA;gBAAA;cAAA;cAAA,MACtC,IAAIC,KAAK,CAAC,eAAe,CAAC;YAAA;cAEpCpB,KAAK,GAAGc,MAAM,CAACG,QAAQ,EAAE;cAAC,KACtBjB,KAAK,CAACqB,EAAE,CAAC,CAAC,CAAC,EAAEnC,aAAa,CAACiC,OAAO,EAAE,CAAC,CAAC,CAAC;gBAAA;gBAAA;cAAA;cAAA,MACjC,IAAIC,KAAK,CAAC,WAAW,CAAC;YAAA;cAEhC;AACR;AACA;AACA;AACA;cACcZ,MAAM,GAAGM,MAAM,CAACQ,OAAO,EAAE;cAAA,MAC3Bd,MAAM,IAAI,CAAC;gBAAA;gBAAA;cAAA;cAAA,MACL,IAAIY,KAAK,CAAC,YAAY,CAAC;YAAA;cAAA,iCAO1BN,MAAM,CAACS,YAAY,EAAE;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA,CAC/B;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;EAAA;AAAA;AAEL1C,OAAO,CAACE,kBAAkB,GAAGA,kBAAkB"},"metadata":{},"sourceType":"script","externalDependencies":[]}