{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createForOfIteratorHelper = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MarkdownParser = void 0;\nvar messageParse_1 = require(\"../client/messageParse\");\nvar MarkdownParser = /*#__PURE__*/function () {\n  function MarkdownParser() {\n    _classCallCheck(this, MarkdownParser);\n  }\n  _createClass(MarkdownParser, null, [{\n    key: \"parse\",\n    value:\n    // TODO maybe there is a better way :shrug:\n    function parse(message) {\n      var i = 0;\n      var keys = {};\n      for (var k in messageParse_1.DEFAULT_DELIMITERS) {\n        keys[k] = false;\n      }\n      var entities = [];\n      var tempEntities = {};\n      while (i < message.length) {\n        var foundIndex = -1;\n        var foundDelim = undefined;\n        for (var _i = 0, _Object$keys = Object.keys(messageParse_1.DEFAULT_DELIMITERS); _i < _Object$keys.length; _i++) {\n          var key = _Object$keys[_i];\n          var index = message.indexOf(key, i);\n          if (index > -1 && (foundIndex === -1 || index < foundIndex)) {\n            foundIndex = index;\n            foundDelim = key;\n          }\n        }\n        if (foundIndex === -1 || foundDelim == undefined) {\n          break;\n        }\n        if (!keys[foundDelim]) {\n          tempEntities[foundDelim] = new messageParse_1.DEFAULT_DELIMITERS[foundDelim]({\n            offset: foundIndex,\n            length: -1,\n            language: \"\"\n          });\n          keys[foundDelim] = true;\n        } else {\n          keys[foundDelim] = false;\n          tempEntities[foundDelim].length = foundIndex - tempEntities[foundDelim].offset;\n          entities.push(tempEntities[foundDelim]);\n        }\n        message = message.replace(foundDelim, \"\");\n        i = foundIndex;\n      }\n      return [message, entities];\n    }\n  }, {\n    key: \"unparse\",\n    value: function unparse(text, entities) {\n      var delimiters = messageParse_1.DEFAULT_DELIMITERS;\n      if (!text || !entities) {\n        return text;\n      }\n      var insertAt = [];\n      var tempDelimiters = new Map();\n      Object.keys(delimiters).forEach(function (key) {\n        tempDelimiters.set(delimiters[key].className, key);\n      });\n      var _iterator = _createForOfIteratorHelper(entities),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var entity = _step.value;\n          var s = entity.offset;\n          var e = entity.offset + entity.length;\n          var delimiter = tempDelimiters.get(entity.className);\n          if (delimiter) {\n            insertAt.push([s, delimiter]);\n            insertAt.push([e, delimiter]);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      insertAt = insertAt.sort(function (a, b) {\n        return a[0] - b[0];\n      });\n      while (insertAt.length) {\n        var _insertAt$pop = insertAt.pop(),\n          _insertAt$pop2 = _slicedToArray(_insertAt$pop, 2),\n          at = _insertAt$pop2[0],\n          what = _insertAt$pop2[1];\n        text = text.slice(0, at) + what + text.slice(at);\n      }\n      return text;\n    }\n  }]);\n  return MarkdownParser;\n}();\nexports.MarkdownParser = MarkdownParser;","map":{"version":3,"names":["Object","defineProperty","exports","value","MarkdownParser","messageParse_1","require","message","i","keys","k","DEFAULT_DELIMITERS","entities","tempEntities","length","foundIndex","foundDelim","undefined","key","index","indexOf","offset","language","push","replace","text","delimiters","insertAt","tempDelimiters","Map","forEach","set","className","entity","s","e","delimiter","get","sort","a","b","pop","at","what","slice"],"sources":["C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/telegram/extensions/markdown.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.MarkdownParser = void 0;\r\nconst messageParse_1 = require(\"../client/messageParse\");\r\nclass MarkdownParser {\r\n    // TODO maybe there is a better way :shrug:\r\n    static parse(message) {\r\n        let i = 0;\r\n        const keys = {};\r\n        for (const k in messageParse_1.DEFAULT_DELIMITERS) {\r\n            keys[k] = false;\r\n        }\r\n        const entities = [];\r\n        const tempEntities = {};\r\n        while (i < message.length) {\r\n            let foundIndex = -1;\r\n            let foundDelim = undefined;\r\n            for (const key of Object.keys(messageParse_1.DEFAULT_DELIMITERS)) {\r\n                const index = message.indexOf(key, i);\r\n                if (index > -1 && (foundIndex === -1 || index < foundIndex)) {\r\n                    foundIndex = index;\r\n                    foundDelim = key;\r\n                }\r\n            }\r\n            if (foundIndex === -1 || foundDelim == undefined) {\r\n                break;\r\n            }\r\n            if (!keys[foundDelim]) {\r\n                tempEntities[foundDelim] = new messageParse_1.DEFAULT_DELIMITERS[foundDelim]({\r\n                    offset: foundIndex,\r\n                    length: -1,\r\n                    language: \"\",\r\n                });\r\n                keys[foundDelim] = true;\r\n            }\r\n            else {\r\n                keys[foundDelim] = false;\r\n                tempEntities[foundDelim].length =\r\n                    foundIndex - tempEntities[foundDelim].offset;\r\n                entities.push(tempEntities[foundDelim]);\r\n            }\r\n            message = message.replace(foundDelim, \"\");\r\n            i = foundIndex;\r\n        }\r\n        return [message, entities];\r\n    }\r\n    static unparse(text, entities) {\r\n        const delimiters = messageParse_1.DEFAULT_DELIMITERS;\r\n        if (!text || !entities) {\r\n            return text;\r\n        }\r\n        let insertAt = [];\r\n        const tempDelimiters = new Map();\r\n        Object.keys(delimiters).forEach((key) => {\r\n            tempDelimiters.set(delimiters[key].className, key);\r\n        });\r\n        for (const entity of entities) {\r\n            const s = entity.offset;\r\n            const e = entity.offset + entity.length;\r\n            const delimiter = tempDelimiters.get(entity.className);\r\n            if (delimiter) {\r\n                insertAt.push([s, delimiter]);\r\n                insertAt.push([e, delimiter]);\r\n            }\r\n        }\r\n        insertAt = insertAt.sort((a, b) => {\r\n            return a[0] - b[0];\r\n        });\r\n        while (insertAt.length) {\r\n            const [at, what] = insertAt.pop();\r\n            text = text.slice(0, at) + what + text.slice(at);\r\n        }\r\n        return text;\r\n    }\r\n}\r\nexports.MarkdownParser = MarkdownParser;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}