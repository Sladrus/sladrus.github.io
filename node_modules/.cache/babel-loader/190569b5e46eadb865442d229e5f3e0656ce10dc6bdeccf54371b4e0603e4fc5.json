{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _createClass from \"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _inherits from \"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _wrapNativeSuper from \"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\";\n/**\r\n * If canceled, a [[`CancellablePromise`]] should throw an `Cancellation` object.\r\n */\nvar Cancellation = /*#__PURE__*/function (_Error) {\n  _inherits(Cancellation, _Error);\n  var _super = _createSuper(Cancellation);\n  function Cancellation() {\n    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Promise canceled.';\n    _classCallCheck(this, Cancellation);\n    return _super.call(this, message);\n  }\n  return _createClass(Cancellation);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n/** @internal */\nvar noop = function noop() {};\n\n/**\r\n * Determines if an arbitrary value is a thenable with a cancel method.\r\n */\nfunction isPromiseWithCancel(value) {\n  return typeof value === 'object' && typeof value.then === 'function' && typeof value.cancel === 'function';\n}\n/**\r\n * A promise with a `cancel` method.\r\n *\r\n * If canceled, the `CancellablePromise` will reject with a [[`Cancellation`]]\r\n * object.\r\n *\r\n * @typeParam T what the `CancellablePromise` resolves to\r\n */\nvar CancellablePromise = /*#__PURE__*/function (_Symbol$toStringTag) {\n  /**\r\n   * @param promise a normal promise or thenable\r\n   * @param cancel a function that cancels `promise`. **Calling `cancel` after\r\n   * `promise` has resolved must be a no-op.**\r\n   */\n  function CancellablePromise(promise, cancel) {\n    _classCallCheck(this, CancellablePromise);\n    this.promise = Promise.resolve(promise);\n    this.cancel = cancel;\n  }\n  /**\r\n   * Analogous to `Promise.then`.\r\n   *\r\n   * `onFulfilled` on `onRejected` can return a value, a normal promise, or a\r\n   * `CancellablePromise`. So you can make a chain a `CancellablePromise`s\r\n   * like this:\r\n   *\r\n   * ```\r\n   * const overallPromise = cancellableAsyncFunction1()\r\n   *     .then(cancellableAsyncFunction2)\r\n   *     .then(cancellableAsyncFunction3)\r\n   *     .then(cancellableAsyncFunction4)\r\n   * ```\r\n   *\r\n   * Then if you call `overallPromise.cancel`, `cancel` is called on all\r\n   * `CancellablePromise`s in the chain! In practice, this means that\r\n   * whichever async operation is in progress will be canceled.\r\n   *\r\n   * @returns a new CancellablePromise\r\n   */\n  _createClass(CancellablePromise, [{\n    key: \"then\",\n    value: function then(onFulfilled, onRejected) {\n      var _this = this;\n      var fulfill;\n      var reject;\n      var callbackPromiseWithCancel;\n      if (onFulfilled) {\n        fulfill = function fulfill(value) {\n          var nextValue = onFulfilled(value);\n          if (isPromiseWithCancel(nextValue)) callbackPromiseWithCancel = nextValue;\n          return nextValue;\n        };\n      }\n      if (onRejected) {\n        reject = function reject(reason) {\n          var nextValue = onRejected(reason);\n          if (isPromiseWithCancel(nextValue)) callbackPromiseWithCancel = nextValue;\n          return nextValue;\n        };\n      }\n      var newPromise = this.promise.then(fulfill, reject);\n      var newCancel = function newCancel() {\n        _this.cancel();\n        callbackPromiseWithCancel === null || callbackPromiseWithCancel === void 0 ? void 0 : callbackPromiseWithCancel.cancel();\n      };\n      return new CancellablePromise(newPromise, newCancel);\n    }\n    /**\r\n     * Analogous to `Promise.catch`.\r\n     */\n  }, {\n    key: \"catch\",\n    value: function _catch(onRejected // eslint-disable-line @typescript-eslint/no-explicit-any -- to match the types used for Promise in the official lib.d.ts\n    ) {\n      return this.then(undefined, onRejected);\n    }\n    /**\r\n     * Attaches a callback that is invoked when the Promise is settled\r\n     * (fulfilled or rejected). The resolved value cannot be modified from the\r\n     * callback.\r\n     * @param onFinally The callback to execute when the Promise is settled\r\n     * (fulfilled or rejected).\r\n     * @returns A Promise for the completion of the callback.\r\n     */\n  }, {\n    key: \"finally\",\n    value: function _finally(onFinally) {\n      return new CancellablePromise(this.promise.finally(onFinally), this.cancel);\n    }\n    /**\r\n     * This is necessary to make `CancellablePromise` assignable to `Promise`.\r\n     */\n    // eslint-disable-next-line class-methods-use-this\n  }, {\n    key: _Symbol$toStringTag,\n    get: function get() {\n      return 'CancellablePromise';\n    }\n  }], [{\n    key: \"resolve\",\n    value: function resolve(value) {\n      return new CancellablePromise(Promise.resolve(value), noop);\n    }\n    /**\r\n     * Analogous to `Promise.reject`.\r\n     *\r\n     * Like `CancellablePromise.resolve`, canceling the returned\r\n     * `CancellablePromise` is a no-op.\r\n     *\r\n     * @param reason this should probably be an `Error` object\r\n     */\n  }, {\n    key: \"reject\",\n    value: function reject(reason) {\n      return new CancellablePromise(Promise.reject(reason), noop);\n    }\n    /**\r\n     * Analogous to `Promise.all`.\r\n     *\r\n     * @param values an array that may contain `CancellablePromise`s, promises,\r\n     * thenables, and resolved values\r\n     * @returns a [[`CancellablePromise`]], which, if canceled, will cancel each\r\n     * of the promises passed in to `CancellablePromise.all`.\r\n     */\n  }, {\n    key: \"all\",\n    value: function all(values) {\n      return new CancellablePromise(Promise.all(values), function () {\n        var _iterator = _createForOfIteratorHelper(values),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var value = _step.value;\n            if (isPromiseWithCancel(value)) value.cancel();\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      });\n    }\n  }, {\n    key: \"allSettled\",\n    value: function allSettled(values) {\n      var cancel = function cancel() {\n        var _iterator2 = _createForOfIteratorHelper(values),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var value = _step2.value;\n            if (isPromiseWithCancel(value)) {\n              value.cancel();\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      };\n      return new CancellablePromise(Promise.allSettled(values), cancel);\n    }\n    /**\r\n     * Creates a `CancellablePromise` that is resolved or rejected when any of\r\n     * the provided `Promises` are resolved or rejected.\r\n     * @param values An array of `Promises`.\r\n     * @returns A new `CancellablePromise`. Canceling it cancels all of the input\r\n     * promises.\r\n     */\n  }, {\n    key: \"race\",\n    value: function race(values) {\n      var cancel = function cancel() {\n        var _iterator3 = _createForOfIteratorHelper(values),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var value = _step3.value;\n            if (isPromiseWithCancel(value)) {\n              value.cancel();\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      };\n      return new CancellablePromise(Promise.race(values), cancel);\n    }\n    // Promise.any is an ES2021 feature. Not yet implemented.\n    // /**\n    //  * The any function returns a `CancellablePromise` that is fulfilled by the\n    //  * first given promise to be fulfilled, or rejected with an `AggregateError`\n    //  * containing an array of rejection reasons if all of the given promises are\n    //  * rejected. It resolves all elements of the passed iterable to promises as\n    //  * it runs this algorithm.\n    //  * @param values An array or iterable of Promises.\n    //  * @returns A new `CancellablePromise`.\n    //  */\n    // any<T>(values: (T | PromiseLike<T>)[] | Iterable<T | PromiseLike<T>>): CancellablePromise<T> {\n    //     return new CancellablePromise(Promise.any(values), cancel))\n    // }\n    /**\r\n     * @returns a `CancellablePromise` that resolves after `ms` milliseconds.\r\n     */\n  }, {\n    key: \"delay\",\n    value: function delay(ms) {\n      var timer;\n      var rejectFn = noop;\n      var promise = new Promise(function (resolve, reject) {\n        timer = setTimeout(function () {\n          resolve();\n          rejectFn = noop;\n        }, ms);\n        rejectFn = reject;\n      });\n      return new CancellablePromise(promise, function () {\n        if (timer) clearTimeout(timer);\n        rejectFn(new Cancellation());\n      });\n    }\n  }]);\n  return CancellablePromise;\n}(Symbol.toStringTag);\n/**\r\n * Takes in a regular `Promise` and returns a `CancellablePromise`. If canceled,\r\n * the `CancellablePromise` will immediately reject with a `Cancellation`, but the asynchronous\r\n * operation will not truly be aborted.\r\n *\r\n * Analogous to\r\n * [make-cancellable-promise](https://www.npmjs.com/package/make-cancellable-promise).\r\n */\nfunction pseudoCancellable(promise) {\n  var canceled = false;\n  var rejectFn = noop;\n  var newPromise = new Promise(function (resolve, reject) {\n    rejectFn = reject;\n    // eslint-disable-next-line promise/catch-or-return -- no catch method on PromiseLike\n    promise.then(function (result) {\n      if (!canceled) {\n        resolve(result);\n        rejectFn = noop;\n      }\n      return undefined;\n    }, function (e) {\n      if (!canceled) reject(e);\n    });\n  });\n  function cancel() {\n    canceled = true;\n    rejectFn(new Cancellation());\n  }\n  return new CancellablePromise(newPromise, cancel);\n}\n/**\r\n * Used to build a single [[`CancellablePromise`]] from a multi-step asynchronous\r\n * flow.\r\n *\r\n * When the overall promise is canceled, each captured promise is canceled. In practice,\r\n * this means the active asynchronous operation is canceled.\r\n *\r\n * ```\r\n * function query(id: number): CancellablePromise<QueryResult> {\r\n *     return buildCancellablePromise(async capture => {\r\n *         const result1 = await capture(api.method1(id))\r\n *\r\n *         // do some stuff\r\n *\r\n *         const result2 = await capture(api.method2(result1.id))\r\n *\r\n *         return { result1, result2 }\r\n *     })\r\n * }\r\n * ```\r\n *\r\n * @param innerFunc an async function that takes in a `capture` function and returns\r\n * a regular `Promise`\r\n */\nfunction buildCancellablePromise(innerFunc) {\n  var capturedPromises = [];\n  var capture = function capture(promise) {\n    capturedPromises.push(promise);\n    return promise;\n  };\n  function cancel() {\n    capturedPromises.forEach(function (p) {\n      return p.cancel();\n    });\n  }\n  return new CancellablePromise(innerFunc(capture), cancel);\n}\nexport { CancellablePromise, Cancellation, buildCancellablePromise, isPromiseWithCancel, pseudoCancellable };","map":{"version":3,"names":["Cancellation","message","Error","noop","isPromiseWithCancel","value","then","cancel","CancellablePromise","promise","Promise","resolve","onFulfilled","onRejected","fulfill","reject","callbackPromiseWithCancel","nextValue","reason","newPromise","newCancel","undefined","onFinally","finally","values","all","allSettled","race","ms","timer","rejectFn","setTimeout","clearTimeout","Symbol","toStringTag","pseudoCancellable","canceled","result","e","buildCancellablePromise","innerFunc","capturedPromises","capture","push","forEach","p"],"sources":["C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/real-cancellable-promise/dist/index.mjs"],"sourcesContent":["/**\r\n * If canceled, a [[`CancellablePromise`]] should throw an `Cancellation` object.\r\n */\r\nclass Cancellation extends Error {\r\n    constructor(message = 'Promise canceled.') {\r\n        super(message);\r\n    }\r\n}\n\n/** @internal */\r\nconst noop = () => { };\n\n/**\r\n * Determines if an arbitrary value is a thenable with a cancel method.\r\n */\r\nfunction isPromiseWithCancel(value) {\r\n    return (typeof value === 'object' &&\r\n        typeof value.then === 'function' &&\r\n        typeof value.cancel === 'function');\r\n}\r\n/**\r\n * A promise with a `cancel` method.\r\n *\r\n * If canceled, the `CancellablePromise` will reject with a [[`Cancellation`]]\r\n * object.\r\n *\r\n * @typeParam T what the `CancellablePromise` resolves to\r\n */\r\nclass CancellablePromise {\r\n    /**\r\n     * @param promise a normal promise or thenable\r\n     * @param cancel a function that cancels `promise`. **Calling `cancel` after\r\n     * `promise` has resolved must be a no-op.**\r\n     */\r\n    constructor(promise, cancel) {\r\n        this.promise = Promise.resolve(promise);\r\n        this.cancel = cancel;\r\n    }\r\n    /**\r\n     * Analogous to `Promise.then`.\r\n     *\r\n     * `onFulfilled` on `onRejected` can return a value, a normal promise, or a\r\n     * `CancellablePromise`. So you can make a chain a `CancellablePromise`s\r\n     * like this:\r\n     *\r\n     * ```\r\n     * const overallPromise = cancellableAsyncFunction1()\r\n     *     .then(cancellableAsyncFunction2)\r\n     *     .then(cancellableAsyncFunction3)\r\n     *     .then(cancellableAsyncFunction4)\r\n     * ```\r\n     *\r\n     * Then if you call `overallPromise.cancel`, `cancel` is called on all\r\n     * `CancellablePromise`s in the chain! In practice, this means that\r\n     * whichever async operation is in progress will be canceled.\r\n     *\r\n     * @returns a new CancellablePromise\r\n     */\r\n    then(onFulfilled, onRejected) {\r\n        let fulfill;\r\n        let reject;\r\n        let callbackPromiseWithCancel;\r\n        if (onFulfilled) {\r\n            fulfill = (value) => {\r\n                const nextValue = onFulfilled(value);\r\n                if (isPromiseWithCancel(nextValue))\r\n                    callbackPromiseWithCancel = nextValue;\r\n                return nextValue;\r\n            };\r\n        }\r\n        if (onRejected) {\r\n            reject = (reason) => {\r\n                const nextValue = onRejected(reason);\r\n                if (isPromiseWithCancel(nextValue))\r\n                    callbackPromiseWithCancel = nextValue;\r\n                return nextValue;\r\n            };\r\n        }\r\n        const newPromise = this.promise.then(fulfill, reject);\r\n        const newCancel = () => {\r\n            this.cancel();\r\n            callbackPromiseWithCancel === null || callbackPromiseWithCancel === void 0 ? void 0 : callbackPromiseWithCancel.cancel();\r\n        };\r\n        return new CancellablePromise(newPromise, newCancel);\r\n    }\r\n    /**\r\n     * Analogous to `Promise.catch`.\r\n     */\r\n    catch(onRejected // eslint-disable-line @typescript-eslint/no-explicit-any -- to match the types used for Promise in the official lib.d.ts\r\n    ) {\r\n        return this.then(undefined, onRejected);\r\n    }\r\n    /**\r\n     * Attaches a callback that is invoked when the Promise is settled\r\n     * (fulfilled or rejected). The resolved value cannot be modified from the\r\n     * callback.\r\n     * @param onFinally The callback to execute when the Promise is settled\r\n     * (fulfilled or rejected).\r\n     * @returns A Promise for the completion of the callback.\r\n     */\r\n    finally(onFinally) {\r\n        return new CancellablePromise(this.promise.finally(onFinally), this.cancel);\r\n    }\r\n    /**\r\n     * This is necessary to make `CancellablePromise` assignable to `Promise`.\r\n     */\r\n    // eslint-disable-next-line class-methods-use-this\r\n    get [Symbol.toStringTag]() {\r\n        return 'CancellablePromise';\r\n    }\r\n    static resolve(value) {\r\n        return new CancellablePromise(Promise.resolve(value), noop);\r\n    }\r\n    /**\r\n     * Analogous to `Promise.reject`.\r\n     *\r\n     * Like `CancellablePromise.resolve`, canceling the returned\r\n     * `CancellablePromise` is a no-op.\r\n     *\r\n     * @param reason this should probably be an `Error` object\r\n     */\r\n    static reject(reason) {\r\n        return new CancellablePromise(Promise.reject(reason), noop);\r\n    }\r\n    /**\r\n     * Analogous to `Promise.all`.\r\n     *\r\n     * @param values an array that may contain `CancellablePromise`s, promises,\r\n     * thenables, and resolved values\r\n     * @returns a [[`CancellablePromise`]], which, if canceled, will cancel each\r\n     * of the promises passed in to `CancellablePromise.all`.\r\n     */\r\n    static all(values) {\r\n        return new CancellablePromise(Promise.all(values), () => {\r\n            for (const value of values) {\r\n                if (isPromiseWithCancel(value))\r\n                    value.cancel();\r\n            }\r\n        });\r\n    }\r\n    static allSettled(values) {\r\n        const cancel = () => {\r\n            for (const value of values) {\r\n                if (isPromiseWithCancel(value)) {\r\n                    value.cancel();\r\n                }\r\n            }\r\n        };\r\n        return new CancellablePromise(Promise.allSettled(values), cancel);\r\n    }\r\n    /**\r\n     * Creates a `CancellablePromise` that is resolved or rejected when any of\r\n     * the provided `Promises` are resolved or rejected.\r\n     * @param values An array of `Promises`.\r\n     * @returns A new `CancellablePromise`. Canceling it cancels all of the input\r\n     * promises.\r\n     */\r\n    static race(values) {\r\n        const cancel = () => {\r\n            for (const value of values) {\r\n                if (isPromiseWithCancel(value)) {\r\n                    value.cancel();\r\n                }\r\n            }\r\n        };\r\n        return new CancellablePromise(Promise.race(values), cancel);\r\n    }\r\n    // Promise.any is an ES2021 feature. Not yet implemented.\r\n    // /**\r\n    //  * The any function returns a `CancellablePromise` that is fulfilled by the\r\n    //  * first given promise to be fulfilled, or rejected with an `AggregateError`\r\n    //  * containing an array of rejection reasons if all of the given promises are\r\n    //  * rejected. It resolves all elements of the passed iterable to promises as\r\n    //  * it runs this algorithm.\r\n    //  * @param values An array or iterable of Promises.\r\n    //  * @returns A new `CancellablePromise`.\r\n    //  */\r\n    // any<T>(values: (T | PromiseLike<T>)[] | Iterable<T | PromiseLike<T>>): CancellablePromise<T> {\r\n    //     return new CancellablePromise(Promise.any(values), cancel))\r\n    // }\r\n    /**\r\n     * @returns a `CancellablePromise` that resolves after `ms` milliseconds.\r\n     */\r\n    static delay(ms) {\r\n        let timer;\r\n        let rejectFn = noop;\r\n        const promise = new Promise((resolve, reject) => {\r\n            timer = setTimeout(() => {\r\n                resolve();\r\n                rejectFn = noop;\r\n            }, ms);\r\n            rejectFn = reject;\r\n        });\r\n        return new CancellablePromise(promise, () => {\r\n            if (timer)\r\n                clearTimeout(timer);\r\n            rejectFn(new Cancellation());\r\n        });\r\n    }\r\n}\n\n/**\r\n * Takes in a regular `Promise` and returns a `CancellablePromise`. If canceled,\r\n * the `CancellablePromise` will immediately reject with a `Cancellation`, but the asynchronous\r\n * operation will not truly be aborted.\r\n *\r\n * Analogous to\r\n * [make-cancellable-promise](https://www.npmjs.com/package/make-cancellable-promise).\r\n */\r\nfunction pseudoCancellable(promise) {\r\n    let canceled = false;\r\n    let rejectFn = noop;\r\n    const newPromise = new Promise((resolve, reject) => {\r\n        rejectFn = reject;\r\n        // eslint-disable-next-line promise/catch-or-return -- no catch method on PromiseLike\r\n        promise.then((result) => {\r\n            if (!canceled) {\r\n                resolve(result);\r\n                rejectFn = noop;\r\n            }\r\n            return undefined;\r\n        }, (e) => {\r\n            if (!canceled)\r\n                reject(e);\r\n        });\r\n    });\r\n    function cancel() {\r\n        canceled = true;\r\n        rejectFn(new Cancellation());\r\n    }\r\n    return new CancellablePromise(newPromise, cancel);\r\n}\r\n/**\r\n * Used to build a single [[`CancellablePromise`]] from a multi-step asynchronous\r\n * flow.\r\n *\r\n * When the overall promise is canceled, each captured promise is canceled. In practice,\r\n * this means the active asynchronous operation is canceled.\r\n *\r\n * ```\r\n * function query(id: number): CancellablePromise<QueryResult> {\r\n *     return buildCancellablePromise(async capture => {\r\n *         const result1 = await capture(api.method1(id))\r\n *\r\n *         // do some stuff\r\n *\r\n *         const result2 = await capture(api.method2(result1.id))\r\n *\r\n *         return { result1, result2 }\r\n *     })\r\n * }\r\n * ```\r\n *\r\n * @param innerFunc an async function that takes in a `capture` function and returns\r\n * a regular `Promise`\r\n */\r\nfunction buildCancellablePromise(innerFunc) {\r\n    const capturedPromises = [];\r\n    const capture = (promise) => {\r\n        capturedPromises.push(promise);\r\n        return promise;\r\n    };\r\n    function cancel() {\r\n        capturedPromises.forEach((p) => p.cancel());\r\n    }\r\n    return new CancellablePromise(innerFunc(capture), cancel);\r\n}\n\nexport { CancellablePromise, Cancellation, buildCancellablePromise, isPromiseWithCancel, pseudoCancellable };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}