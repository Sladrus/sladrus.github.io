{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _slicedToArray = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _asyncToGenerator = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MTProtoState = void 0;\nvar buffer_1 = require(\"buffer/\");\nvar big_integer_1 = __importDefault(require(\"big-integer\"));\nvar __1 = require(\"../\");\nvar tl_1 = require(\"../tl\");\nvar Helpers_1 = require(\"../Helpers\");\nvar core_1 = require(\"../tl/core\");\nvar extensions_1 = require(\"../extensions\");\nvar IGE_1 = require(\"../crypto/IGE\");\nvar errors_1 = require(\"../errors\");\nvar MTProtoState = /*#__PURE__*/function () {\n  /**\r\n   *\r\n   `telethon.network.mtprotosender.MTProtoSender` needs to hold a state\r\n   in order to be able to encrypt and decrypt incoming/outgoing messages,\r\n   as well as generating the message IDs. Instances of this class hold\r\n   together all the required information.\r\n     It doesn't make sense to use `telethon.sessions.abstract.Session` for\r\n   the sender because the sender should *not* be concerned about storing\r\n   this information to disk, as one may create as many senders as they\r\n   desire to any other data center, or some CDN. Using the same session\r\n   for all these is not a good idea as each need their own authkey, and\r\n   the concept of \"copying\" sessions with the unnecessary entities or\r\n   updates state for these connections doesn't make sense.\r\n     While it would be possible to have a `MTProtoPlainState` that does no\r\n   encryption so that it was usable through the `MTProtoLayer` and thus\r\n   avoid the need for a `MTProtoPlainSender`, the `MTProtoLayer` is more\r\n   focused to efficiency and this state is also more advanced (since it\r\n   supports gzipping and invoking after other message IDs). There are too\r\n   many methods that would be needed to make it convenient to use for the\r\n   authentication process, at which point the `MTProtoPlainSender` is better\r\n   * @param authKey\r\n   * @param loggers\r\n   * @param securityChecks\r\n   */\n  function MTProtoState(authKey, loggers) {\n    var securityChecks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    _classCallCheck(this, MTProtoState);\n    this.authKey = authKey;\n    this._log = loggers;\n    this.timeOffset = 0;\n    this.salt = big_integer_1.default.zero;\n    this._sequence = 0;\n    this.id = this._lastMsgId = big_integer_1.default.zero;\n    this.msgIds = [];\n    this.securityChecks = securityChecks;\n    this.reset();\n  }\n  /**\r\n   * Resets the state\r\n   */\n  _createClass(MTProtoState, [{\n    key: \"reset\",\n    value: function reset() {\n      // Session IDs can be random on every connection\n      this.id = __1.helpers.generateRandomLong(true);\n      this._sequence = 0;\n      this._lastMsgId = big_integer_1.default.zero;\n      this.msgIds = [];\n    }\n    /**\r\n     * Updates the message ID to a new one,\r\n     * used when the time offset changed.\r\n     * @param message\r\n     */\n  }, {\n    key: \"updateMessageId\",\n    value: function updateMessageId(message) {\n      message.msgId = this._getNewMsgId();\n    }\n    /**\r\n     * Calculate the key based on Telegram guidelines, specifying whether it's the client or not\r\n     * @param authKey\r\n     * @param msgKey\r\n     * @param client\r\n     * @returns {{iv: Buffer, key: Buffer}}\r\n     */\n  }, {\n    key: \"_calcKey\",\n    value: function () {\n      var _calcKey2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(authKey, msgKey, client) {\n        var x, _yield$Promise$all, _yield$Promise$all2, sha256a, sha256b, key, iv;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              x = client ? 0 : 8;\n              _context.next = 3;\n              return Promise.all([(0, Helpers_1.sha256)(buffer_1.Buffer.concat([msgKey, authKey.slice(x, x + 36)])), (0, Helpers_1.sha256)(buffer_1.Buffer.concat([authKey.slice(x + 40, x + 76), msgKey]))]);\n            case 3:\n              _yield$Promise$all = _context.sent;\n              _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n              sha256a = _yield$Promise$all2[0];\n              sha256b = _yield$Promise$all2[1];\n              key = buffer_1.Buffer.concat([sha256a.slice(0, 8), sha256b.slice(8, 24), sha256a.slice(24, 32)]);\n              iv = buffer_1.Buffer.concat([sha256b.slice(0, 8), sha256a.slice(8, 24), sha256b.slice(24, 32)]);\n              return _context.abrupt(\"return\", {\n                key: key,\n                iv: iv\n              });\n            case 10:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }));\n      function _calcKey(_x, _x2, _x3) {\n        return _calcKey2.apply(this, arguments);\n      }\n      return _calcKey;\n    }()\n    /**\r\n     * Writes a message containing the given data into buffer.\r\n     * Returns the message id.\r\n     * @param buffer\r\n     * @param data\r\n     * @param contentRelated\r\n     * @param afterId\r\n     */\n  }, {\n    key: \"writeDataAsMessage\",\n    value: function () {\n      var _writeDataAsMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(buffer, data, contentRelated, afterId) {\n        var msgId, seqNo, body, s, b, m;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              msgId = this._getNewMsgId();\n              seqNo = this._getSeqNo(contentRelated);\n              if (afterId) {\n                _context2.next = 8;\n                break;\n              }\n              _context2.next = 5;\n              return core_1.GZIPPacked.gzipIfSmaller(contentRelated, data);\n            case 5:\n              body = _context2.sent;\n              _context2.next = 11;\n              break;\n            case 8:\n              _context2.next = 10;\n              return core_1.GZIPPacked.gzipIfSmaller(contentRelated, new tl_1.Api.InvokeAfterMsg({\n                msgId: afterId,\n                query: {\n                  getBytes: function getBytes() {\n                    return data;\n                  }\n                }\n              }).getBytes());\n            case 10:\n              body = _context2.sent;\n            case 11:\n              s = buffer_1.Buffer.alloc(4);\n              s.writeInt32LE(seqNo, 0);\n              b = buffer_1.Buffer.alloc(4);\n              b.writeInt32LE(body.length, 0);\n              m = (0, Helpers_1.toSignedLittleBuffer)(msgId, 8);\n              buffer.write(buffer_1.Buffer.concat([m, s, b]));\n              buffer.write(body);\n              return _context2.abrupt(\"return\", msgId);\n            case 19:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function writeDataAsMessage(_x4, _x5, _x6, _x7) {\n        return _writeDataAsMessage.apply(this, arguments);\n      }\n      return writeDataAsMessage;\n    }()\n    /**\r\n     * Encrypts the given message data using the current authorization key\r\n     * following MTProto 2.0 guidelines core.telegram.org/mtproto/description.\r\n     * @param data\r\n     */\n  }, {\n    key: \"encryptMessageData\",\n    value: function () {\n      var _encryptMessageData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(data) {\n        var authKey, s, i, padding, msgKeyLarge, msgKey, _yield$this$_calcKey, iv, key, keyId;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              if (this.authKey) {\n                _context3.next = 2;\n                break;\n              }\n              throw new Error(\"Auth key unset\");\n            case 2:\n              _context3.next = 4;\n              return this.authKey.waitForKey();\n            case 4:\n              authKey = this.authKey.getKey();\n              if (authKey) {\n                _context3.next = 7;\n                break;\n              }\n              throw new Error(\"Auth key unset\");\n            case 7:\n              if (!(!this.salt || !this.id || !authKey || !this.authKey.keyId)) {\n                _context3.next = 9;\n                break;\n              }\n              throw new Error(\"Unset params\");\n            case 9:\n              s = (0, Helpers_1.toSignedLittleBuffer)(this.salt, 8);\n              i = (0, Helpers_1.toSignedLittleBuffer)(this.id, 8);\n              data = buffer_1.Buffer.concat([buffer_1.Buffer.concat([s, i]), data]);\n              padding = __1.helpers.generateRandomBytes(__1.helpers.mod(-(data.length + 12), 16) + 12); // Being substr(what, offset, length); x = 0 for client\n              // \"msg_key_large = SHA256(substr(auth_key, 88+x, 32) + pt + padding)\"\n              _context3.next = 15;\n              return (0, Helpers_1.sha256)(buffer_1.Buffer.concat([authKey.slice(88, 88 + 32), data, padding]));\n            case 15:\n              msgKeyLarge = _context3.sent;\n              // \"msg_key = substr (msg_key_large, 8, 16)\"\n              msgKey = msgKeyLarge.slice(8, 24);\n              _context3.next = 19;\n              return this._calcKey(authKey, msgKey, true);\n            case 19:\n              _yield$this$_calcKey = _context3.sent;\n              iv = _yield$this$_calcKey.iv;\n              key = _yield$this$_calcKey.key;\n              keyId = __1.helpers.readBufferFromBigInt(this.authKey.keyId, 8);\n              return _context3.abrupt(\"return\", buffer_1.Buffer.concat([keyId, msgKey, new IGE_1.IGE(key, iv).encryptIge(buffer_1.Buffer.concat([data, padding]))]));\n            case 24:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function encryptMessageData(_x8) {\n        return _encryptMessageData.apply(this, arguments);\n      }\n      return encryptMessageData;\n    }()\n    /**\r\n     * Inverse of `encrypt_message_data` for incoming server messages.\r\n     * @param body\r\n     */\n  }, {\n    key: \"decryptMessageData\",\n    value: function () {\n      var _decryptMessageData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(body) {\n        var keyId, authKey, msgKey, _yield$this$_calcKey2, iv, key, ourKey, reader, serverId, remoteMsgId, remoteSequence, obj;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              if (this.authKey) {\n                _context4.next = 2;\n                break;\n              }\n              throw new Error(\"Auth key unset\");\n            case 2:\n              if (!(body.length < 8)) {\n                _context4.next = 4;\n                break;\n              }\n              throw new errors_1.InvalidBufferError(body);\n            case 4:\n              // TODO Check salt,sessionId, and sequenceNumber\n              keyId = __1.helpers.readBigIntFromBuffer(body.slice(0, 8));\n              if (!(!this.authKey.keyId || keyId.neq(this.authKey.keyId))) {\n                _context4.next = 7;\n                break;\n              }\n              throw new errors_1.SecurityError(\"Server replied with an invalid auth key\");\n            case 7:\n              authKey = this.authKey.getKey();\n              if (authKey) {\n                _context4.next = 10;\n                break;\n              }\n              throw new errors_1.SecurityError(\"Unset AuthKey\");\n            case 10:\n              msgKey = body.slice(8, 24);\n              _context4.next = 13;\n              return this._calcKey(authKey, msgKey, false);\n            case 13:\n              _yield$this$_calcKey2 = _context4.sent;\n              iv = _yield$this$_calcKey2.iv;\n              key = _yield$this$_calcKey2.key;\n              body = new IGE_1.IGE(key, iv).decryptIge(body.slice(24));\n              // https://core.telegram.org/mtproto/security_guidelines\n              // Sections \"checking sha256 hash\" and \"message length\"\n              _context4.next = 19;\n              return (0, Helpers_1.sha256)(buffer_1.Buffer.concat([authKey.slice(96, 96 + 32), body]));\n            case 19:\n              ourKey = _context4.sent;\n              if (msgKey.equals(ourKey.slice(8, 24))) {\n                _context4.next = 22;\n                break;\n              }\n              throw new errors_1.SecurityError(\"Received msg_key doesn't match with expected one\");\n            case 22:\n              reader = new extensions_1.BinaryReader(body);\n              reader.readLong(); // removeSalt\n              serverId = reader.readLong();\n              if (serverId.neq(this.id)) {\n                // throw new SecurityError('Server replied with a wrong session ID');\n              }\n              remoteMsgId = reader.readLong();\n              if (!(this.msgIds.includes(remoteMsgId.toString()) && this.securityChecks)) {\n                _context4.next = 29;\n                break;\n              }\n              throw new errors_1.SecurityError(\"Duplicate msgIds\");\n            case 29:\n              if (this.msgIds.length > 500) {\n                this.msgIds.shift();\n              }\n              this.msgIds.push(remoteMsgId.toString());\n              remoteSequence = reader.readInt();\n              reader.readInt(); // msgLen for the inner object, padding ignored\n              // We could read msg_len bytes and use those in a new reader to read\n              // the next TLObject without including the padding, but since the\n              // reader isn't used for anything else after this, it's unnecessary.\n              obj = reader.tgReadObject();\n              return _context4.abrupt(\"return\", new core_1.TLMessage(remoteMsgId, remoteSequence, obj));\n            case 35:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function decryptMessageData(_x9) {\n        return _decryptMessageData.apply(this, arguments);\n      }\n      return decryptMessageData;\n    }()\n    /**\r\n     * Generates a new unique message ID based on the current\r\n     * time (in ms) since epoch, applying a known time offset.\r\n     * @private\r\n     */\n  }, {\n    key: \"_getNewMsgId\",\n    value: function _getNewMsgId() {\n      var now = new Date().getTime() / 1000 + this.timeOffset;\n      var nanoseconds = Math.floor((now - Math.floor(now)) * 1e9);\n      var newMsgId = (0, big_integer_1.default)(Math.floor(now)).shiftLeft((0, big_integer_1.default)(32)).or((0, big_integer_1.default)(nanoseconds).shiftLeft((0, big_integer_1.default)(2)));\n      if (this._lastMsgId.greaterOrEquals(newMsgId)) {\n        newMsgId = this._lastMsgId.add((0, big_integer_1.default)(4));\n      }\n      this._lastMsgId = newMsgId;\n      return newMsgId;\n    }\n    /**\r\n     * Updates the time offset to the correct\r\n     * one given a known valid message ID.\r\n     * @param correctMsgId {BigInteger}\r\n     */\n  }, {\n    key: \"updateTimeOffset\",\n    value: function updateTimeOffset(correctMsgId) {\n      var bad = this._getNewMsgId();\n      var old = this.timeOffset;\n      var now = Math.floor(new Date().getTime() / 1000);\n      var correct = correctMsgId.shiftRight((0, big_integer_1.default)(32)).toJSNumber();\n      this.timeOffset = correct - now;\n      if (this.timeOffset !== old) {\n        this._lastMsgId = big_integer_1.default.zero;\n        this._log.debug(\"Updated time offset (old offset \".concat(old, \", bad \").concat(bad, \", good \").concat(correctMsgId, \", new \").concat(this.timeOffset, \")\"));\n      }\n      return this.timeOffset;\n    }\n    /**\r\n     * Generates the next sequence number depending on whether\r\n     * it should be for a content-related query or not.\r\n     * @param contentRelated\r\n     * @private\r\n     */\n  }, {\n    key: \"_getSeqNo\",\n    value: function _getSeqNo(contentRelated) {\n      if (contentRelated) {\n        var result = this._sequence * 2 + 1;\n        this._sequence += 1;\n        return result;\n      } else {\n        return this._sequence * 2;\n      }\n    }\n  }]);\n  return MTProtoState;\n}();\nexports.MTProtoState = MTProtoState;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","MTProtoState","buffer_1","require","big_integer_1","__1","tl_1","Helpers_1","core_1","extensions_1","IGE_1","errors_1","authKey","loggers","securityChecks","_log","timeOffset","salt","default","zero","_sequence","id","_lastMsgId","msgIds","reset","helpers","generateRandomLong","message","msgId","_getNewMsgId","msgKey","client","x","Promise","all","sha256","Buffer","concat","slice","sha256a","sha256b","key","iv","buffer","data","contentRelated","afterId","seqNo","_getSeqNo","GZIPPacked","gzipIfSmaller","body","Api","InvokeAfterMsg","query","getBytes","s","alloc","writeInt32LE","b","length","m","toSignedLittleBuffer","write","Error","waitForKey","getKey","keyId","i","padding","generateRandomBytes","msgKeyLarge","_calcKey","readBufferFromBigInt","IGE","encryptIge","InvalidBufferError","readBigIntFromBuffer","neq","SecurityError","decryptIge","ourKey","equals","reader","BinaryReader","readLong","serverId","remoteMsgId","includes","toString","shift","push","remoteSequence","readInt","obj","tgReadObject","TLMessage","now","Date","getTime","nanoseconds","Math","floor","newMsgId","shiftLeft","or","greaterOrEquals","add","correctMsgId","bad","old","correct","shiftRight","toJSNumber","debug","result"],"sources":["C:/Users/Yakov/Desktop/projects/node-projects/node-js-key-monitor/sladrus.github.io/node_modules/telegram/network/MTProtoState.js"],"sourcesContent":["\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.MTProtoState = void 0;\r\nconst buffer_1 = require(\"buffer/\");\r\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\r\nconst __1 = require(\"../\");\r\nconst tl_1 = require(\"../tl\");\r\nconst Helpers_1 = require(\"../Helpers\");\r\nconst core_1 = require(\"../tl/core\");\r\nconst extensions_1 = require(\"../extensions\");\r\nconst IGE_1 = require(\"../crypto/IGE\");\r\nconst errors_1 = require(\"../errors\");\r\nclass MTProtoState {\r\n    /**\r\n     *\r\n     `telethon.network.mtprotosender.MTProtoSender` needs to hold a state\r\n     in order to be able to encrypt and decrypt incoming/outgoing messages,\r\n     as well as generating the message IDs. Instances of this class hold\r\n     together all the required information.\r\n\r\n     It doesn't make sense to use `telethon.sessions.abstract.Session` for\r\n     the sender because the sender should *not* be concerned about storing\r\n     this information to disk, as one may create as many senders as they\r\n     desire to any other data center, or some CDN. Using the same session\r\n     for all these is not a good idea as each need their own authkey, and\r\n     the concept of \"copying\" sessions with the unnecessary entities or\r\n     updates state for these connections doesn't make sense.\r\n\r\n     While it would be possible to have a `MTProtoPlainState` that does no\r\n     encryption so that it was usable through the `MTProtoLayer` and thus\r\n     avoid the need for a `MTProtoPlainSender`, the `MTProtoLayer` is more\r\n     focused to efficiency and this state is also more advanced (since it\r\n     supports gzipping and invoking after other message IDs). There are too\r\n     many methods that would be needed to make it convenient to use for the\r\n     authentication process, at which point the `MTProtoPlainSender` is better\r\n     * @param authKey\r\n     * @param loggers\r\n     * @param securityChecks\r\n     */\r\n    constructor(authKey, loggers, securityChecks = true) {\r\n        this.authKey = authKey;\r\n        this._log = loggers;\r\n        this.timeOffset = 0;\r\n        this.salt = big_integer_1.default.zero;\r\n        this._sequence = 0;\r\n        this.id = this._lastMsgId = big_integer_1.default.zero;\r\n        this.msgIds = [];\r\n        this.securityChecks = securityChecks;\r\n        this.reset();\r\n    }\r\n    /**\r\n     * Resets the state\r\n     */\r\n    reset() {\r\n        // Session IDs can be random on every connection\r\n        this.id = __1.helpers.generateRandomLong(true);\r\n        this._sequence = 0;\r\n        this._lastMsgId = big_integer_1.default.zero;\r\n        this.msgIds = [];\r\n    }\r\n    /**\r\n     * Updates the message ID to a new one,\r\n     * used when the time offset changed.\r\n     * @param message\r\n     */\r\n    updateMessageId(message) {\r\n        message.msgId = this._getNewMsgId();\r\n    }\r\n    /**\r\n     * Calculate the key based on Telegram guidelines, specifying whether it's the client or not\r\n     * @param authKey\r\n     * @param msgKey\r\n     * @param client\r\n     * @returns {{iv: Buffer, key: Buffer}}\r\n     */\r\n    async _calcKey(authKey, msgKey, client) {\r\n        const x = client ? 0 : 8;\r\n        const [sha256a, sha256b] = await Promise.all([\r\n            (0, Helpers_1.sha256)(buffer_1.Buffer.concat([msgKey, authKey.slice(x, x + 36)])),\r\n            (0, Helpers_1.sha256)(buffer_1.Buffer.concat([authKey.slice(x + 40, x + 76), msgKey])),\r\n        ]);\r\n        const key = buffer_1.Buffer.concat([\r\n            sha256a.slice(0, 8),\r\n            sha256b.slice(8, 24),\r\n            sha256a.slice(24, 32),\r\n        ]);\r\n        const iv = buffer_1.Buffer.concat([\r\n            sha256b.slice(0, 8),\r\n            sha256a.slice(8, 24),\r\n            sha256b.slice(24, 32),\r\n        ]);\r\n        return { key, iv };\r\n    }\r\n    /**\r\n     * Writes a message containing the given data into buffer.\r\n     * Returns the message id.\r\n     * @param buffer\r\n     * @param data\r\n     * @param contentRelated\r\n     * @param afterId\r\n     */\r\n    async writeDataAsMessage(buffer, data, contentRelated, afterId) {\r\n        const msgId = this._getNewMsgId();\r\n        const seqNo = this._getSeqNo(contentRelated);\r\n        let body;\r\n        if (!afterId) {\r\n            body = await core_1.GZIPPacked.gzipIfSmaller(contentRelated, data);\r\n        }\r\n        else {\r\n            body = await core_1.GZIPPacked.gzipIfSmaller(contentRelated, new tl_1.Api.InvokeAfterMsg({\r\n                msgId: afterId,\r\n                query: {\r\n                    getBytes() {\r\n                        return data;\r\n                    },\r\n                },\r\n            }).getBytes());\r\n        }\r\n        const s = buffer_1.Buffer.alloc(4);\r\n        s.writeInt32LE(seqNo, 0);\r\n        const b = buffer_1.Buffer.alloc(4);\r\n        b.writeInt32LE(body.length, 0);\r\n        const m = (0, Helpers_1.toSignedLittleBuffer)(msgId, 8);\r\n        buffer.write(buffer_1.Buffer.concat([m, s, b]));\r\n        buffer.write(body);\r\n        return msgId;\r\n    }\r\n    /**\r\n     * Encrypts the given message data using the current authorization key\r\n     * following MTProto 2.0 guidelines core.telegram.org/mtproto/description.\r\n     * @param data\r\n     */\r\n    async encryptMessageData(data) {\r\n        if (!this.authKey) {\r\n            throw new Error(\"Auth key unset\");\r\n        }\r\n        await this.authKey.waitForKey();\r\n        const authKey = this.authKey.getKey();\r\n        if (!authKey) {\r\n            throw new Error(\"Auth key unset\");\r\n        }\r\n        if (!this.salt || !this.id || !authKey || !this.authKey.keyId) {\r\n            throw new Error(\"Unset params\");\r\n        }\r\n        const s = (0, Helpers_1.toSignedLittleBuffer)(this.salt, 8);\r\n        const i = (0, Helpers_1.toSignedLittleBuffer)(this.id, 8);\r\n        data = buffer_1.Buffer.concat([buffer_1.Buffer.concat([s, i]), data]);\r\n        const padding = __1.helpers.generateRandomBytes(__1.helpers.mod(-(data.length + 12), 16) + 12);\r\n        // Being substr(what, offset, length); x = 0 for client\r\n        // \"msg_key_large = SHA256(substr(auth_key, 88+x, 32) + pt + padding)\"\r\n        const msgKeyLarge = await (0, Helpers_1.sha256)(buffer_1.Buffer.concat([authKey.slice(88, 88 + 32), data, padding]));\r\n        // \"msg_key = substr (msg_key_large, 8, 16)\"\r\n        const msgKey = msgKeyLarge.slice(8, 24);\r\n        const { iv, key } = await this._calcKey(authKey, msgKey, true);\r\n        const keyId = __1.helpers.readBufferFromBigInt(this.authKey.keyId, 8);\r\n        return buffer_1.Buffer.concat([\r\n            keyId,\r\n            msgKey,\r\n            new IGE_1.IGE(key, iv).encryptIge(buffer_1.Buffer.concat([data, padding])),\r\n        ]);\r\n    }\r\n    /**\r\n     * Inverse of `encrypt_message_data` for incoming server messages.\r\n     * @param body\r\n     */\r\n    async decryptMessageData(body) {\r\n        if (!this.authKey) {\r\n            throw new Error(\"Auth key unset\");\r\n        }\r\n        if (body.length < 8) {\r\n            throw new errors_1.InvalidBufferError(body);\r\n        }\r\n        // TODO Check salt,sessionId, and sequenceNumber\r\n        const keyId = __1.helpers.readBigIntFromBuffer(body.slice(0, 8));\r\n        if (!this.authKey.keyId || keyId.neq(this.authKey.keyId)) {\r\n            throw new errors_1.SecurityError(\"Server replied with an invalid auth key\");\r\n        }\r\n        const authKey = this.authKey.getKey();\r\n        if (!authKey) {\r\n            throw new errors_1.SecurityError(\"Unset AuthKey\");\r\n        }\r\n        const msgKey = body.slice(8, 24);\r\n        const { iv, key } = await this._calcKey(authKey, msgKey, false);\r\n        body = new IGE_1.IGE(key, iv).decryptIge(body.slice(24));\r\n        // https://core.telegram.org/mtproto/security_guidelines\r\n        // Sections \"checking sha256 hash\" and \"message length\"\r\n        const ourKey = await (0, Helpers_1.sha256)(buffer_1.Buffer.concat([authKey.slice(96, 96 + 32), body]));\r\n        if (!msgKey.equals(ourKey.slice(8, 24))) {\r\n            throw new errors_1.SecurityError(\"Received msg_key doesn't match with expected one\");\r\n        }\r\n        const reader = new extensions_1.BinaryReader(body);\r\n        reader.readLong(); // removeSalt\r\n        const serverId = reader.readLong();\r\n        if (serverId.neq(this.id)) {\r\n            // throw new SecurityError('Server replied with a wrong session ID');\r\n        }\r\n        const remoteMsgId = reader.readLong();\r\n        if (this.msgIds.includes(remoteMsgId.toString()) &&\r\n            this.securityChecks) {\r\n            throw new errors_1.SecurityError(\"Duplicate msgIds\");\r\n        }\r\n        if (this.msgIds.length > 500) {\r\n            this.msgIds.shift();\r\n        }\r\n        this.msgIds.push(remoteMsgId.toString());\r\n        const remoteSequence = reader.readInt();\r\n        reader.readInt(); // msgLen for the inner object, padding ignored\r\n        // We could read msg_len bytes and use those in a new reader to read\r\n        // the next TLObject without including the padding, but since the\r\n        // reader isn't used for anything else after this, it's unnecessary.\r\n        const obj = reader.tgReadObject();\r\n        return new core_1.TLMessage(remoteMsgId, remoteSequence, obj);\r\n    }\r\n    /**\r\n     * Generates a new unique message ID based on the current\r\n     * time (in ms) since epoch, applying a known time offset.\r\n     * @private\r\n     */\r\n    _getNewMsgId() {\r\n        const now = new Date().getTime() / 1000 + this.timeOffset;\r\n        const nanoseconds = Math.floor((now - Math.floor(now)) * 1e9);\r\n        let newMsgId = (0, big_integer_1.default)(Math.floor(now))\r\n            .shiftLeft((0, big_integer_1.default)(32))\r\n            .or((0, big_integer_1.default)(nanoseconds).shiftLeft((0, big_integer_1.default)(2)));\r\n        if (this._lastMsgId.greaterOrEquals(newMsgId)) {\r\n            newMsgId = this._lastMsgId.add((0, big_integer_1.default)(4));\r\n        }\r\n        this._lastMsgId = newMsgId;\r\n        return newMsgId;\r\n    }\r\n    /**\r\n     * Updates the time offset to the correct\r\n     * one given a known valid message ID.\r\n     * @param correctMsgId {BigInteger}\r\n     */\r\n    updateTimeOffset(correctMsgId) {\r\n        const bad = this._getNewMsgId();\r\n        const old = this.timeOffset;\r\n        const now = Math.floor(new Date().getTime() / 1000);\r\n        const correct = correctMsgId.shiftRight((0, big_integer_1.default)(32)).toJSNumber();\r\n        this.timeOffset = correct - now;\r\n        if (this.timeOffset !== old) {\r\n            this._lastMsgId = big_integer_1.default.zero;\r\n            this._log.debug(`Updated time offset (old offset ${old}, bad ${bad}, good ${correctMsgId}, new ${this.timeOffset})`);\r\n        }\r\n        return this.timeOffset;\r\n    }\r\n    /**\r\n     * Generates the next sequence number depending on whether\r\n     * it should be for a content-related query or not.\r\n     * @param contentRelated\r\n     * @private\r\n     */\r\n    _getSeqNo(contentRelated) {\r\n        if (contentRelated) {\r\n            const result = this._sequence * 2 + 1;\r\n            this._sequence += 1;\r\n            return result;\r\n        }\r\n        else {\r\n            return this._sequence * 2;\r\n        }\r\n    }\r\n}\r\nexports.MTProtoState = MTProtoState;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}